<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="VM-specific methods for scanning roots/objects."><title>Scanning in mmtk::vm::scanning - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../static.files/rustdoc-f3501f0f5ae15dfb.css" id="mainThemeStyle"><div id="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="mmtk" data-themes="" data-resource-suffix="" data-rustdoc-version="1.71.1 (eb26296b5 2023-08-03)" data-search-js="search-4926e5fc22a5646a.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-0f8c037637f9eb3e.css" data-theme-dark-css="dark-1097f8e92a01e3cf.css" data-theme-ayu-css="ayu-614652228113ac93.css" ></div><script src="../../../static.files/storage-62ce34ea385b278a.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../static.files/main-f0540c1d82cde29b.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../../../static.files/light-0f8c037637f9eb3e.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../../../static.files/dark-1097f8e92a01e3cf.css"><link rel="stylesheet" href="../../../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc trait"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../../../mmtk/index.html"><img class="rust-logo" src="../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../../../mmtk/index.html"><img class="rust-logo" src="../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Scanning</a></h2><div class="sidebar-elems"><section><h3><a href="#required-methods">Required Methods</a></h3><ul class="block"><li><a href="#tymethod.notify_initial_thread_scan_complete">notify_initial_thread_scan_complete</a></li><li><a href="#tymethod.prepare_for_roots_re_scanning">prepare_for_roots_re_scanning</a></li><li><a href="#tymethod.scan_object">scan_object</a></li><li><a href="#tymethod.scan_roots_in_mutator_thread">scan_roots_in_mutator_thread</a></li><li><a href="#tymethod.scan_vm_specific_roots">scan_vm_specific_roots</a></li><li><a href="#tymethod.supports_return_barrier">supports_return_barrier</a></li></ul><h3><a href="#provided-methods">Provided Methods</a></h3><ul class="block"><li><a href="#method.forward_weak_refs">forward_weak_refs</a></li><li><a href="#method.process_weak_refs">process_weak_refs</a></li><li><a href="#method.scan_object_and_trace_edges">scan_object_and_trace_edges</a></li><li><a href="#method.support_edge_enqueuing">support_edge_enqueuing</a></li></ul><h3><a href="#implementors">Implementors</a></h3></section><h2><a href="index.html">In mmtk::vm::scanning</a></h2></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Trait <a href="../../index.html">mmtk</a>::<wbr><a href="../index.html">vm</a>::<wbr><a href="index.html">scanning</a>::<wbr><a class="trait" href="#">Scanning</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../../../src/mmtk/vm/scanning.rs.html#132-329">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub trait Scanning&lt;VM: <a class="trait" href="../trait.VMBinding.html" title="trait mmtk::vm::VMBinding">VMBinding</a>&gt; {
    // Required methods
    fn <a href="#tymethod.scan_object" class="fn">scan_object</a>&lt;EV: <a class="trait" href="trait.EdgeVisitor.html" title="trait mmtk::vm::scanning::EdgeVisitor">EdgeVisitor</a>&lt;VM::<a class="associatedtype" href="../trait.VMBinding.html#associatedtype.VMEdge" title="type mmtk::vm::VMBinding::VMEdge">VMEdge</a>&gt;&gt;(
        tls: <a class="struct" href="../../util/opaque_pointer/struct.VMWorkerThread.html" title="struct mmtk::util::opaque_pointer::VMWorkerThread">VMWorkerThread</a>,
        object: <a class="struct" href="../../util/address/struct.ObjectReference.html" title="struct mmtk::util::address::ObjectReference">ObjectReference</a>,
        edge_visitor: <a class="primitive" href="https://doc.rust-lang.org/1.71.1/std/primitive.reference.html">&amp;mut EV</a>
    );
<span class="item-spacer"></span>    fn <a href="#tymethod.notify_initial_thread_scan_complete" class="fn">notify_initial_thread_scan_complete</a>(
        partial_scan: <a class="primitive" href="https://doc.rust-lang.org/1.71.1/std/primitive.bool.html">bool</a>,
        tls: <a class="struct" href="../../util/opaque_pointer/struct.VMWorkerThread.html" title="struct mmtk::util::opaque_pointer::VMWorkerThread">VMWorkerThread</a>
    );
<span class="item-spacer"></span>    fn <a href="#tymethod.scan_roots_in_mutator_thread" class="fn">scan_roots_in_mutator_thread</a>(
        tls: <a class="struct" href="../../util/opaque_pointer/struct.VMWorkerThread.html" title="struct mmtk::util::opaque_pointer::VMWorkerThread">VMWorkerThread</a>,
        mutator: &amp;'static mut <a class="struct" href="../../plan/mutator_context/struct.Mutator.html" title="struct mmtk::plan::mutator_context::Mutator">Mutator</a>&lt;VM&gt;,
        factory: impl <a class="trait" href="trait.RootsWorkFactory.html" title="trait mmtk::vm::scanning::RootsWorkFactory">RootsWorkFactory</a>&lt;VM::<a class="associatedtype" href="../trait.VMBinding.html#associatedtype.VMEdge" title="type mmtk::vm::VMBinding::VMEdge">VMEdge</a>&gt;
    );
<span class="item-spacer"></span>    fn <a href="#tymethod.scan_vm_specific_roots" class="fn">scan_vm_specific_roots</a>(
        tls: <a class="struct" href="../../util/opaque_pointer/struct.VMWorkerThread.html" title="struct mmtk::util::opaque_pointer::VMWorkerThread">VMWorkerThread</a>,
        factory: impl <a class="trait" href="trait.RootsWorkFactory.html" title="trait mmtk::vm::scanning::RootsWorkFactory">RootsWorkFactory</a>&lt;VM::<a class="associatedtype" href="../trait.VMBinding.html#associatedtype.VMEdge" title="type mmtk::vm::VMBinding::VMEdge">VMEdge</a>&gt;
    );
<span class="item-spacer"></span>    fn <a href="#tymethod.supports_return_barrier" class="fn">supports_return_barrier</a>() -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.71.1/std/primitive.bool.html">bool</a>;
<span class="item-spacer"></span>    fn <a href="#tymethod.prepare_for_roots_re_scanning" class="fn">prepare_for_roots_re_scanning</a>();

    // Provided methods
    fn <a href="#method.support_edge_enqueuing" class="fn">support_edge_enqueuing</a>(
        _tls: <a class="struct" href="../../util/opaque_pointer/struct.VMWorkerThread.html" title="struct mmtk::util::opaque_pointer::VMWorkerThread">VMWorkerThread</a>,
        _object: <a class="struct" href="../../util/address/struct.ObjectReference.html" title="struct mmtk::util::address::ObjectReference">ObjectReference</a>
    ) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.71.1/std/primitive.bool.html">bool</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.scan_object_and_trace_edges" class="fn">scan_object_and_trace_edges</a>&lt;OT: <a class="trait" href="trait.ObjectTracer.html" title="trait mmtk::vm::scanning::ObjectTracer">ObjectTracer</a>&gt;(
        _tls: <a class="struct" href="../../util/opaque_pointer/struct.VMWorkerThread.html" title="struct mmtk::util::opaque_pointer::VMWorkerThread">VMWorkerThread</a>,
        _object: <a class="struct" href="../../util/address/struct.ObjectReference.html" title="struct mmtk::util::address::ObjectReference">ObjectReference</a>,
        _object_tracer: <a class="primitive" href="https://doc.rust-lang.org/1.71.1/std/primitive.reference.html">&amp;mut OT</a>
    ) { ... }
<span class="item-spacer"></span>    fn <a href="#method.process_weak_refs" class="fn">process_weak_refs</a>(
        _worker: &amp;mut <a class="struct" href="../../scheduler/worker/struct.GCWorker.html" title="struct mmtk::scheduler::worker::GCWorker">GCWorker</a>&lt;VM&gt;,
        _tracer_context: impl <a class="trait" href="trait.ObjectTracerContext.html" title="trait mmtk::vm::scanning::ObjectTracerContext">ObjectTracerContext</a>&lt;VM&gt;
    ) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.71.1/std/primitive.bool.html">bool</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.forward_weak_refs" class="fn">forward_weak_refs</a>(
        _worker: &amp;mut <a class="struct" href="../../scheduler/worker/struct.GCWorker.html" title="struct mmtk::scheduler::worker::GCWorker">GCWorker</a>&lt;VM&gt;,
        _tracer_context: impl <a class="trait" href="trait.ObjectTracerContext.html" title="trait mmtk::vm::scanning::ObjectTracerContext">ObjectTracerContext</a>&lt;VM&gt;
    ) { ... }
}</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>VM-specific methods for scanning roots/objects.</p>
</div></details><h2 id="required-methods" class="small-section-header">Required Methods<a href="#required-methods" class="anchor">§</a></h2><div class="methods"><details class="toggle method-toggle" open><summary><section id="tymethod.scan_object" class="method"><a class="srclink rightside" href="../../../src/mmtk/vm/scanning.rs.html#165-169">source</a><h4 class="code-header">fn <a href="#tymethod.scan_object" class="fn">scan_object</a>&lt;EV: <a class="trait" href="trait.EdgeVisitor.html" title="trait mmtk::vm::scanning::EdgeVisitor">EdgeVisitor</a>&lt;VM::<a class="associatedtype" href="../trait.VMBinding.html#associatedtype.VMEdge" title="type mmtk::vm::VMBinding::VMEdge">VMEdge</a>&gt;&gt;(
    tls: <a class="struct" href="../../util/opaque_pointer/struct.VMWorkerThread.html" title="struct mmtk::util::opaque_pointer::VMWorkerThread">VMWorkerThread</a>,
    object: <a class="struct" href="../../util/address/struct.ObjectReference.html" title="struct mmtk::util::address::ObjectReference">ObjectReference</a>,
    edge_visitor: <a class="primitive" href="https://doc.rust-lang.org/1.71.1/std/primitive.reference.html">&amp;mut EV</a>
)</h4></section></summary><div class="docblock"><p>Delegated scanning of a object, visiting each reference field encountered.</p>
<p>The VM shall call <code>edge_visitor.visit_edge</code> on each reference field.</p>
<p>The VM may skip a reference field if it holds a null reference.  If the VM supports tagged
references, it must skip tagged reference fields which are not holding references.</p>
<p>The <code>memory_manager::is_mmtk_object</code> function can be used in this function if</p>
<ul>
<li>the “is_mmtk_object” feature is enabled, and</li>
<li><code>VM::VMObjectModel::NEED_VO_BITS_DURING_TRACING</code> is true.</li>
</ul>
<p>Arguments:</p>
<ul>
<li><code>tls</code>: The VM-specific thread-local storage for the current worker.</li>
<li><code>object</code>: The object to be scanned.</li>
<li><code>edge_visitor</code>: Called back for each edge.</li>
</ul>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.notify_initial_thread_scan_complete" class="method"><a class="srclink rightside" href="../../../src/mmtk/vm/scanning.rs.html#205">source</a><h4 class="code-header">fn <a href="#tymethod.notify_initial_thread_scan_complete" class="fn">notify_initial_thread_scan_complete</a>(partial_scan: <a class="primitive" href="https://doc.rust-lang.org/1.71.1/std/primitive.bool.html">bool</a>, tls: <a class="struct" href="../../util/opaque_pointer/struct.VMWorkerThread.html" title="struct mmtk::util::opaque_pointer::VMWorkerThread">VMWorkerThread</a>)</h4></section></summary><div class="docblock"><p>MMTk calls this method at the first time during a collection that thread’s stacks
have been scanned. This can be used (for example) to clean up
obsolete compiled methods that are no longer being executed.</p>
<p>Arguments:</p>
<ul>
<li><code>partial_scan</code>: Whether the scan was partial or full-heap.</li>
<li><code>tls</code>: The GC thread that is performing the thread scan.</li>
</ul>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.scan_roots_in_mutator_thread" class="method"><a class="srclink rightside" href="../../../src/mmtk/vm/scanning.rs.html#225-229">source</a><h4 class="code-header">fn <a href="#tymethod.scan_roots_in_mutator_thread" class="fn">scan_roots_in_mutator_thread</a>(
    tls: <a class="struct" href="../../util/opaque_pointer/struct.VMWorkerThread.html" title="struct mmtk::util::opaque_pointer::VMWorkerThread">VMWorkerThread</a>,
    mutator: &amp;'static mut <a class="struct" href="../../plan/mutator_context/struct.Mutator.html" title="struct mmtk::plan::mutator_context::Mutator">Mutator</a>&lt;VM&gt;,
    factory: impl <a class="trait" href="trait.RootsWorkFactory.html" title="trait mmtk::vm::scanning::RootsWorkFactory">RootsWorkFactory</a>&lt;VM::<a class="associatedtype" href="../trait.VMBinding.html#associatedtype.VMEdge" title="type mmtk::vm::VMBinding::VMEdge">VMEdge</a>&gt;
)</h4></section></summary><div class="docblock"><p>Scan one mutator for stack roots.</p>
<p>Some VM bindings may not be able to implement this method.
For example, the VM binding may only be able to enumerate all threads and
scan them while enumerating, but cannot scan stacks individually when given
the references of threads.
In that case, it can leave this method empty, and deal with stack
roots in <a href="trait.Scanning.html#tymethod.scan_vm_specific_roots" title="associated function mmtk::vm::scanning::Scanning::scan_vm_specific_roots"><code>Scanning::scan_vm_specific_roots</code></a>. However, in that case, MMTk
does not know those roots are stack roots, and cannot perform any possible
optimization for the stack roots.</p>
<p>The <code>memory_manager::is_mmtk_object</code> function can be used in this function if</p>
<ul>
<li>the “is_mmtk_object” feature is enabled.</li>
</ul>
<p>Arguments:</p>
<ul>
<li><code>tls</code>: The GC thread that is performing this scanning.</li>
<li><code>mutator</code>: The reference to the mutator whose roots will be scanned.</li>
<li><code>factory</code>: The VM uses it to create work packets for scanning roots.</li>
</ul>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.scan_vm_specific_roots" class="method"><a class="srclink rightside" href="../../../src/mmtk/vm/scanning.rs.html#240">source</a><h4 class="code-header">fn <a href="#tymethod.scan_vm_specific_roots" class="fn">scan_vm_specific_roots</a>(
    tls: <a class="struct" href="../../util/opaque_pointer/struct.VMWorkerThread.html" title="struct mmtk::util::opaque_pointer::VMWorkerThread">VMWorkerThread</a>,
    factory: impl <a class="trait" href="trait.RootsWorkFactory.html" title="trait mmtk::vm::scanning::RootsWorkFactory">RootsWorkFactory</a>&lt;VM::<a class="associatedtype" href="../trait.VMBinding.html#associatedtype.VMEdge" title="type mmtk::vm::VMBinding::VMEdge">VMEdge</a>&gt;
)</h4></section></summary><div class="docblock"><p>Scan VM-specific roots. The creation of all root scan tasks (except thread scanning)
goes here.</p>
<p>The <code>memory_manager::is_mmtk_object</code> function can be used in this function if</p>
<ul>
<li>the “is_mmtk_object” feature is enabled.</li>
</ul>
<p>Arguments:</p>
<ul>
<li><code>tls</code>: The GC thread that is performing this scanning.</li>
<li><code>factory</code>: The VM uses it to create work packets for scanning roots.</li>
</ul>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.supports_return_barrier" class="method"><a class="srclink rightside" href="../../../src/mmtk/vm/scanning.rs.html#243">source</a><h4 class="code-header">fn <a href="#tymethod.supports_return_barrier" class="fn">supports_return_barrier</a>() -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.71.1/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Return whether the VM supports return barriers. This is unused at the moment.</p>
</div></details><section id="tymethod.prepare_for_roots_re_scanning" class="method"><a class="srclink rightside" href="../../../src/mmtk/vm/scanning.rs.html#245">source</a><h4 class="code-header">fn <a href="#tymethod.prepare_for_roots_re_scanning" class="fn">prepare_for_roots_re_scanning</a>()</h4></section></div><h2 id="provided-methods" class="small-section-header">Provided Methods<a href="#provided-methods" class="anchor">§</a></h2><div class="methods"><details class="toggle method-toggle" open><summary><section id="method.support_edge_enqueuing" class="method"><a class="srclink rightside" href="../../../src/mmtk/vm/scanning.rs.html#146-148">source</a><h4 class="code-header">fn <a href="#method.support_edge_enqueuing" class="fn">support_edge_enqueuing</a>(
    _tls: <a class="struct" href="../../util/opaque_pointer/struct.VMWorkerThread.html" title="struct mmtk::util::opaque_pointer::VMWorkerThread">VMWorkerThread</a>,
    _object: <a class="struct" href="../../util/address/struct.ObjectReference.html" title="struct mmtk::util::address::ObjectReference">ObjectReference</a>
) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.71.1/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Return true if the given object supports edge enqueuing.</p>
<ul>
<li>If this returns true, MMTk core will call <code>scan_object</code> on the object.</li>
<li>Otherwise, MMTk core will call <code>scan_object_and_trace_edges</code> on the object.</li>
</ul>
<p>For maximum performance, the VM should support edge-enqueuing for as many objects as
practical.  Also note that this method is called for every object to be scanned, so it
must be fast.  The VM binding should avoid expensive checks and keep it as efficient as
possible.</p>
<p>Arguments:</p>
<ul>
<li><code>tls</code>: The VM-specific thread-local storage for the current worker.</li>
<li><code>object</code>: The object to be scanned.</li>
</ul>
</div></details><details class="toggle method-toggle" open><summary><section id="method.scan_object_and_trace_edges" class="method"><a class="srclink rightside" href="../../../src/mmtk/vm/scanning.rs.html#190-196">source</a><h4 class="code-header">fn <a href="#method.scan_object_and_trace_edges" class="fn">scan_object_and_trace_edges</a>&lt;OT: <a class="trait" href="trait.ObjectTracer.html" title="trait mmtk::vm::scanning::ObjectTracer">ObjectTracer</a>&gt;(
    _tls: <a class="struct" href="../../util/opaque_pointer/struct.VMWorkerThread.html" title="struct mmtk::util::opaque_pointer::VMWorkerThread">VMWorkerThread</a>,
    _object: <a class="struct" href="../../util/address/struct.ObjectReference.html" title="struct mmtk::util::address::ObjectReference">ObjectReference</a>,
    _object_tracer: <a class="primitive" href="https://doc.rust-lang.org/1.71.1/std/primitive.reference.html">&amp;mut OT</a>
)</h4></section></summary><div class="docblock"><p>Delegated scanning of a object, visiting each reference field encountered, and trace the
objects pointed by each field.</p>
<p>The VM shall call <code>object_tracer.trace_object</code> on the value held in each reference field,
and assign the returned value back to the field.  If the VM uses tagged references, the
value passed to <code>object_tracer.trace_object</code> shall be the <code>ObjectReference</code> to the object
without any tag bits.</p>
<p>The VM may skip a reference field if it holds a null reference.  If the VM supports tagged
references, it must skip tagged reference fields which are not holding references.</p>
<p>The <code>memory_manager::is_mmtk_object</code> function can be used in this function if</p>
<ul>
<li>the “is_mmtk_object” feature is enabled, and</li>
<li><code>VM::VMObjectModel::NEED_VO_BITS_DURING_TRACING</code> is true.</li>
</ul>
<p>Arguments:</p>
<ul>
<li><code>tls</code>: The VM-specific thread-local storage for the current worker.</li>
<li><code>object</code>: The object to be scanned.</li>
<li><code>object_tracer</code>: Called back for the content of each edge.</li>
</ul>
</div></details><details class="toggle method-toggle" open><summary><section id="method.process_weak_refs" class="method"><a class="srclink rightside" href="../../../src/mmtk/vm/scanning.rs.html#307-312">source</a><h4 class="code-header">fn <a href="#method.process_weak_refs" class="fn">process_weak_refs</a>(
    _worker: &amp;mut <a class="struct" href="../../scheduler/worker/struct.GCWorker.html" title="struct mmtk::scheduler::worker::GCWorker">GCWorker</a>&lt;VM&gt;,
    _tracer_context: impl <a class="trait" href="trait.ObjectTracerContext.html" title="trait mmtk::vm::scanning::ObjectTracerContext">ObjectTracerContext</a>&lt;VM&gt;
) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.71.1/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Process weak references.</p>
<p>This function is called after a transitive closure is completed.</p>
<p>MMTk core enables the VM binding to do the following in this function:</p>
<ol>
<li>Query if an object is already reached in this transitive closure.</li>
<li>Get the new address of an object if it is already reached.</li>
<li>Keep an object and its descendents alive if not yet reached.</li>
<li>Request this function to be called again after transitive closure is finished again.</li>
</ol>
<p>The VM binding can query if an object is currently reached by calling
<code>ObjectReference::is_reachable()</code>.</p>
<p>If an object is already reached, the VM binding can get its new address by calling
<code>ObjectReference::get_forwarded_object()</code> as the object may have been moved.</p>
<p>If an object is not yet reached, the VM binding can keep that object and its descendents
alive.  To do this, the VM binding should use <code>tracer_context.with_tracer</code> to get access to
an <code>ObjectTracer</code>, and then call its <code>trace_object(object)</code> method.  The <code>trace_object</code>
method will return the new address of the <code>object</code> if it moved the object, or its original
address if not moved.  Implementation-wise, the <code>ObjectTracer</code> may contain an internal
queue for newly traced objects, and will flush the queue when <code>tracer_context.with_tracer</code>
returns. Therefore, it is recommended to reuse the <code>ObjectTracer</code> instance to trace
multiple objects.</p>
<p><em>Note that if <code>trace_object</code> is called on an already reached object, the behavior will be
equivalent to <code>ObjectReference::get_forwarded_object()</code>.  It will return the new address if
the GC already moved the object when tracing that object, or the original address if the GC
did not move the object when tracing it.  In theory, the VM binding can use <code>trace_object</code>
wherever <code>ObjectReference::get_forwarded_object()</code> is needed.  However, if a VM never
resurrects objects, it should completely avoid touching <code>tracer_context</code>, and exclusively
use <code>ObjectReference::get_forwarded_object()</code> to get new addresses of objects.  By doing
so, the VM binding can avoid accidentally resurrecting objects.</em></p>
<p>The VM binding can return <code>true</code> from <code>process_weak_refs</code> to request <code>process_weak_refs</code>
to be called again after the MMTk core finishes transitive closure again from the objects
newly visited by <code>ObjectTracer::trace_object</code>.  This is useful if a VM supports multiple
levels of reachabilities (such as Java) or ephemerons.</p>
<p>Implementation-wise, this function is called as the “sentinel” of the <code>VMRefClosure</code> work
bucket, which means it is called when all work packets in that bucket have finished.  The
<code>tracer_context</code> expands the transitive closure by adding more work packets in the same
bucket.  This means if <code>process_weak_refs</code> returns true, those work packets will have
finished (completing the transitive closure) by the time <code>process_weak_refs</code> is called
again.  The VM binding can make use of this by adding custom work packets into the
<code>VMRefClosure</code> bucket.  The bucket will be <code>VMRefForwarding</code>, instead, when forwarding.
See below.</p>
<p>The <code>memory_manager::is_mmtk_object</code> function can be used in this function if</p>
<ul>
<li>the “is_mmtk_object” feature is enabled, and</li>
<li><code>VM::VMObjectModel::NEED_VO_BITS_DURING_TRACING</code> is true.</li>
</ul>
<p>Arguments:</p>
<ul>
<li><code>worker</code>: The current GC worker.</li>
<li><code>tracer_context</code>: Use this to get access an <code>ObjectTracer</code> and use it to retain and
update weak references.</li>
</ul>
<p>This function shall return true if this function needs to be called again after the GC
finishes expanding the transitive closure from the objects kept alive.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.forward_weak_refs" class="method"><a class="srclink rightside" href="../../../src/mmtk/vm/scanning.rs.html#324-328">source</a><h4 class="code-header">fn <a href="#method.forward_weak_refs" class="fn">forward_weak_refs</a>(
    _worker: &amp;mut <a class="struct" href="../../scheduler/worker/struct.GCWorker.html" title="struct mmtk::scheduler::worker::GCWorker">GCWorker</a>&lt;VM&gt;,
    _tracer_context: impl <a class="trait" href="trait.ObjectTracerContext.html" title="trait mmtk::vm::scanning::ObjectTracerContext">ObjectTracerContext</a>&lt;VM&gt;
)</h4></section></summary><div class="docblock"><p>Forward weak references.</p>
<p>This function will only be called in the forwarding stage when using the mark-compact GC
algorithm.  Mark-compact computes transive closure twice during each GC.  It marks objects
in the first transitive closure, and forward references in the second transitive closure.</p>
<p>Arguments:</p>
<ul>
<li><code>worker</code>: The current GC worker.</li>
<li><code>tracer_context</code>: Use this to get access an <code>ObjectTracer</code> and use it to update weak
references.</li>
</ul>
</div></details></div><h2 id="implementors" class="small-section-header">Implementors<a href="#implementors" class="anchor">§</a></h2><div id="implementors-list"></div><script src="../../../implementors/mmtk/vm/scanning/trait.Scanning.js" async></script></section></div></main></body></html>