<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="VM-specific methods for scanning roots/objects."><meta name="keywords" content="rust, rustlang, rust-lang, Scanning"><title>Scanning in mmtk::vm::scanning - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" href="../../../normalize.css"><link rel="stylesheet" href="../../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" href="../../../ayu.css" disabled><link rel="stylesheet" href="../../../dark.css" disabled><link rel="stylesheet" href="../../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../../storage.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../main.js"></script><noscript><link rel="stylesheet" href="../../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../../favicon.svg"></head><body class="rustdoc trait"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../../../mmtk/index.html"><div class="logo-container"><img class="rust-logo" src="../../../rust-logo.svg" alt="logo"></div></a><h2></h2></nav><nav class="sidebar"><a class="sidebar-logo" href="../../../mmtk/index.html"><div class="logo-container"><img class="rust-logo" src="../../../rust-logo.svg" alt="logo"></div></a><h2 class="location"><a href="#">Scanning</a></h2><div class="sidebar-elems"><section><h3><a href="#required-methods">Required Methods</a></h3><ul class="block"><li><a href="#tymethod.notify_initial_thread_scan_complete">notify_initial_thread_scan_complete</a></li><li><a href="#tymethod.prepare_for_roots_re_scanning">prepare_for_roots_re_scanning</a></li><li><a href="#tymethod.scan_object">scan_object</a></li><li><a href="#tymethod.scan_roots_in_mutator_thread">scan_roots_in_mutator_thread</a></li><li><a href="#tymethod.scan_vm_specific_roots">scan_vm_specific_roots</a></li><li><a href="#tymethod.supports_return_barrier">supports_return_barrier</a></li></ul><h3><a href="#provided-methods">Provided Methods</a></h3><ul class="block"><li><a href="#method.forward_weak_refs">forward_weak_refs</a></li><li><a href="#method.process_weak_refs">process_weak_refs</a></li><li><a href="#method.scan_object_and_trace_edges">scan_object_and_trace_edges</a></li><li><a href="#method.support_edge_enqueuing">support_edge_enqueuing</a></li></ul><h3><a href="#implementors">Implementors</a></h3></section><h2><a href="index.html">In mmtk::vm::scanning</a></h2></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../wheel.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1 class="fqn">Trait <a href="../../index.html">mmtk</a>::<wbr><a href="../index.html">vm</a>::<wbr><a href="index.html">scanning</a>::<wbr><a class="trait" href="#">Scanning</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../../../clipboard.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../../../src/mmtk/vm/scanning.rs.html#123-307">source</a> · <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></div><div class="item-decl"><pre class="rust trait"><code>pub trait Scanning&lt;VM:&nbsp;<a class="trait" href="../trait.VMBinding.html" title="trait mmtk::vm::VMBinding">VMBinding</a>&gt; {
    fn <a href="#tymethod.scan_object" class="fnname">scan_object</a>&lt;EV:&nbsp;<a class="trait" href="trait.EdgeVisitor.html" title="trait mmtk::vm::scanning::EdgeVisitor">EdgeVisitor</a>&lt;VM::<a class="associatedtype" href="../trait.VMBinding.html#associatedtype.VMEdge" title="type mmtk::vm::VMBinding::VMEdge">VMEdge</a>&gt;&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tls: <a class="struct" href="../../util/opaque_pointer/struct.VMWorkerThread.html" title="struct mmtk::util::opaque_pointer::VMWorkerThread">VMWorkerThread</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;object: <a class="struct" href="../../util/address/struct.ObjectReference.html" title="struct mmtk::util::address::ObjectReference">ObjectReference</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edge_visitor: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;mut </a>EV<br>&nbsp;&nbsp;&nbsp;&nbsp;);
<span class="item-spacer"></span>    fn <a href="#tymethod.notify_initial_thread_scan_complete" class="fnname">notify_initial_thread_scan_complete</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;partial_scan: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tls: <a class="struct" href="../../util/opaque_pointer/struct.VMWorkerThread.html" title="struct mmtk::util::opaque_pointer::VMWorkerThread">VMWorkerThread</a><br>&nbsp;&nbsp;&nbsp;&nbsp;);
<span class="item-spacer"></span>    fn <a href="#tymethod.scan_roots_in_mutator_thread" class="fnname">scan_roots_in_mutator_thread</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tls: <a class="struct" href="../../util/opaque_pointer/struct.VMWorkerThread.html" title="struct mmtk::util::opaque_pointer::VMWorkerThread">VMWorkerThread</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mutator: &amp;'static mut <a class="struct" href="../../plan/mutator_context/struct.Mutator.html" title="struct mmtk::plan::mutator_context::Mutator">Mutator</a>&lt;VM&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;factory: impl <a class="trait" href="trait.RootsWorkFactory.html" title="trait mmtk::vm::scanning::RootsWorkFactory">RootsWorkFactory</a>&lt;VM::<a class="associatedtype" href="../trait.VMBinding.html#associatedtype.VMEdge" title="type mmtk::vm::VMBinding::VMEdge">VMEdge</a>&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;);
<span class="item-spacer"></span>    fn <a href="#tymethod.scan_vm_specific_roots" class="fnname">scan_vm_specific_roots</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tls: <a class="struct" href="../../util/opaque_pointer/struct.VMWorkerThread.html" title="struct mmtk::util::opaque_pointer::VMWorkerThread">VMWorkerThread</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;factory: impl <a class="trait" href="trait.RootsWorkFactory.html" title="trait mmtk::vm::scanning::RootsWorkFactory">RootsWorkFactory</a>&lt;VM::<a class="associatedtype" href="../trait.VMBinding.html#associatedtype.VMEdge" title="type mmtk::vm::VMBinding::VMEdge">VMEdge</a>&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;);
<span class="item-spacer"></span>    fn <a href="#tymethod.supports_return_barrier" class="fnname">supports_return_barrier</a>() -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a>;
<span class="item-spacer"></span>    fn <a href="#tymethod.prepare_for_roots_re_scanning" class="fnname">prepare_for_roots_re_scanning</a>();

    fn <a href="#method.support_edge_enqueuing" class="fnname">support_edge_enqueuing</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_tls: <a class="struct" href="../../util/opaque_pointer/struct.VMWorkerThread.html" title="struct mmtk::util::opaque_pointer::VMWorkerThread">VMWorkerThread</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_object: <a class="struct" href="../../util/address/struct.ObjectReference.html" title="struct mmtk::util::address::ObjectReference">ObjectReference</a><br>&nbsp;&nbsp;&nbsp;&nbsp;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.scan_object_and_trace_edges" class="fnname">scan_object_and_trace_edges</a>&lt;OT:&nbsp;<a class="trait" href="trait.ObjectTracer.html" title="trait mmtk::vm::scanning::ObjectTracer">ObjectTracer</a>&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_tls: <a class="struct" href="../../util/opaque_pointer/struct.VMWorkerThread.html" title="struct mmtk::util::opaque_pointer::VMWorkerThread">VMWorkerThread</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_object: <a class="struct" href="../../util/address/struct.ObjectReference.html" title="struct mmtk::util::address::ObjectReference">ObjectReference</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_object_tracer: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;mut </a>OT<br>&nbsp;&nbsp;&nbsp;&nbsp;) { ... }
<span class="item-spacer"></span>    fn <a href="#method.process_weak_refs" class="fnname">process_weak_refs</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_worker: &amp;mut <a class="struct" href="../../scheduler/worker/struct.GCWorker.html" title="struct mmtk::scheduler::worker::GCWorker">GCWorker</a>&lt;VM&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_tracer_context: impl <a class="trait" href="trait.ObjectTracerContext.html" title="trait mmtk::vm::scanning::ObjectTracerContext">ObjectTracerContext</a>&lt;VM&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.forward_weak_refs" class="fnname">forward_weak_refs</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_worker: &amp;mut <a class="struct" href="../../scheduler/worker/struct.GCWorker.html" title="struct mmtk::scheduler::worker::GCWorker">GCWorker</a>&lt;VM&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_tracer_context: impl <a class="trait" href="trait.ObjectTracerContext.html" title="trait mmtk::vm::scanning::ObjectTracerContext">ObjectTracerContext</a>&lt;VM&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;) { ... }
}</code></pre></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>VM-specific methods for scanning roots/objects.</p>
</div></details><h2 id="required-methods" class="small-section-header">Required Methods<a href="#required-methods" class="anchor"></a></h2><div class="methods"><details class="rustdoc-toggle method-toggle" open><summary><section id="tymethod.scan_object" class="method has-srclink"><a class="srclink rightside" href="../../../src/mmtk/vm/scanning.rs.html#156-160">source</a><h4 class="code-header">fn <a href="#tymethod.scan_object" class="fnname">scan_object</a>&lt;EV:&nbsp;<a class="trait" href="trait.EdgeVisitor.html" title="trait mmtk::vm::scanning::EdgeVisitor">EdgeVisitor</a>&lt;VM::<a class="associatedtype" href="../trait.VMBinding.html#associatedtype.VMEdge" title="type mmtk::vm::VMBinding::VMEdge">VMEdge</a>&gt;&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;tls: <a class="struct" href="../../util/opaque_pointer/struct.VMWorkerThread.html" title="struct mmtk::util::opaque_pointer::VMWorkerThread">VMWorkerThread</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;object: <a class="struct" href="../../util/address/struct.ObjectReference.html" title="struct mmtk::util::address::ObjectReference">ObjectReference</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;edge_visitor: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;mut </a>EV<br>)</h4></section></summary><div class="docblock"><p>Delegated scanning of a object, visiting each reference field encountered.</p>
<p>The VM shall call <code>edge_visitor.visit_edge</code> on each reference field.</p>
<p>The VM may skip a reference field if it holds a null reference.  If the VM supports tagged
references, it must skip tagged reference fields which are not holding references.</p>
<p>The <code>memory_manager::is_mmtk_object</code> function can be used in this function if</p>
<ul>
<li>the “is_mmtk_object” feature is enabled, and</li>
<li><code>VM::VMObjectModel::NEED_VO_BITS_DURING_TRACING</code> is true.</li>
</ul>
<p>Arguments:</p>
<ul>
<li><code>tls</code>: The VM-specific thread-local storage for the current worker.</li>
<li><code>object</code>: The object to be scanned.</li>
<li><code>edge_visitor</code>: Called back for each edge.</li>
</ul>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="tymethod.notify_initial_thread_scan_complete" class="method has-srclink"><a class="srclink rightside" href="../../../src/mmtk/vm/scanning.rs.html#196">source</a><h4 class="code-header">fn <a href="#tymethod.notify_initial_thread_scan_complete" class="fnname">notify_initial_thread_scan_complete</a>(partial_scan: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a>, tls: <a class="struct" href="../../util/opaque_pointer/struct.VMWorkerThread.html" title="struct mmtk::util::opaque_pointer::VMWorkerThread">VMWorkerThread</a>)</h4></section></summary><div class="docblock"><p>MMTk calls this method at the first time during a collection that thread’s stacks
have been scanned. This can be used (for example) to clean up
obsolete compiled methods that are no longer being executed.</p>
<p>Arguments:</p>
<ul>
<li><code>partial_scan</code>: Whether the scan was partial or full-heap.</li>
<li><code>tls</code>: The GC thread that is performing the thread scan.</li>
</ul>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="tymethod.scan_roots_in_mutator_thread" class="method has-srclink"><a class="srclink rightside" href="../../../src/mmtk/vm/scanning.rs.html#216-220">source</a><h4 class="code-header">fn <a href="#tymethod.scan_roots_in_mutator_thread" class="fnname">scan_roots_in_mutator_thread</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;tls: <a class="struct" href="../../util/opaque_pointer/struct.VMWorkerThread.html" title="struct mmtk::util::opaque_pointer::VMWorkerThread">VMWorkerThread</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;mutator: &amp;'static mut <a class="struct" href="../../plan/mutator_context/struct.Mutator.html" title="struct mmtk::plan::mutator_context::Mutator">Mutator</a>&lt;VM&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;factory: impl <a class="trait" href="trait.RootsWorkFactory.html" title="trait mmtk::vm::scanning::RootsWorkFactory">RootsWorkFactory</a>&lt;VM::<a class="associatedtype" href="../trait.VMBinding.html#associatedtype.VMEdge" title="type mmtk::vm::VMBinding::VMEdge">VMEdge</a>&gt;<br>)</h4></section></summary><div class="docblock"><p>Scan one mutator for stack roots.</p>
<p>Some VM bindings may not be able to implement this method.
For example, the VM binding may only be able to enumerate all threads and
scan them while enumerating, but cannot scan stacks individually when given
the references of threads.
In that case, it can leave this method empty, and deal with stack
roots in <a href="trait.Scanning.html#tymethod.scan_vm_specific_roots" title="Scanning::scan_vm_specific_roots"><code>Scanning::scan_vm_specific_roots</code></a>. However, in that case, MMTk
does not know those roots are stack roots, and cannot perform any possible
optimization for the stack roots.</p>
<p>The <code>memory_manager::is_mmtk_object</code> function can be used in this function if</p>
<ul>
<li>the “is_mmtk_object” feature is enabled.</li>
</ul>
<p>Arguments:</p>
<ul>
<li><code>tls</code>: The GC thread that is performing this scanning.</li>
<li><code>mutator</code>: The reference to the mutator whose roots will be scanned.</li>
<li><code>factory</code>: The VM uses it to create work packets for scanning roots.</li>
</ul>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="tymethod.scan_vm_specific_roots" class="method has-srclink"><a class="srclink rightside" href="../../../src/mmtk/vm/scanning.rs.html#231">source</a><h4 class="code-header">fn <a href="#tymethod.scan_vm_specific_roots" class="fnname">scan_vm_specific_roots</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;tls: <a class="struct" href="../../util/opaque_pointer/struct.VMWorkerThread.html" title="struct mmtk::util::opaque_pointer::VMWorkerThread">VMWorkerThread</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;factory: impl <a class="trait" href="trait.RootsWorkFactory.html" title="trait mmtk::vm::scanning::RootsWorkFactory">RootsWorkFactory</a>&lt;VM::<a class="associatedtype" href="../trait.VMBinding.html#associatedtype.VMEdge" title="type mmtk::vm::VMBinding::VMEdge">VMEdge</a>&gt;<br>)</h4></section></summary><div class="docblock"><p>Scan VM-specific roots. The creation of all root scan tasks (except thread scanning)
goes here.</p>
<p>The <code>memory_manager::is_mmtk_object</code> function can be used in this function if</p>
<ul>
<li>the “is_mmtk_object” feature is enabled.</li>
</ul>
<p>Arguments:</p>
<ul>
<li><code>tls</code>: The GC thread that is performing this scanning.</li>
<li><code>factory</code>: The VM uses it to create work packets for scanning roots.</li>
</ul>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="tymethod.supports_return_barrier" class="method has-srclink"><a class="srclink rightside" href="../../../src/mmtk/vm/scanning.rs.html#234">source</a><h4 class="code-header">fn <a href="#tymethod.supports_return_barrier" class="fnname">supports_return_barrier</a>() -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Return whether the VM supports return barriers. This is unused at the moment.</p>
</div></details><section id="tymethod.prepare_for_roots_re_scanning" class="method has-srclink"><a class="srclink rightside" href="../../../src/mmtk/vm/scanning.rs.html#236">source</a><h4 class="code-header">fn <a href="#tymethod.prepare_for_roots_re_scanning" class="fnname">prepare_for_roots_re_scanning</a>()</h4></section></div><h2 id="provided-methods" class="small-section-header">Provided Methods<a href="#provided-methods" class="anchor"></a></h2><div class="methods"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.support_edge_enqueuing" class="method has-srclink"><a class="srclink rightside" href="../../../src/mmtk/vm/scanning.rs.html#137-139">source</a><h4 class="code-header">fn <a href="#method.support_edge_enqueuing" class="fnname">support_edge_enqueuing</a>(_tls: <a class="struct" href="../../util/opaque_pointer/struct.VMWorkerThread.html" title="struct mmtk::util::opaque_pointer::VMWorkerThread">VMWorkerThread</a>, _object: <a class="struct" href="../../util/address/struct.ObjectReference.html" title="struct mmtk::util::address::ObjectReference">ObjectReference</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Return true if the given object supports edge enqueuing.</p>
<ul>
<li>If this returns true, MMTk core will call <code>scan_object</code> on the object.</li>
<li>Otherwise, MMTk core will call <code>scan_object_and_trace_edges</code> on the object.</li>
</ul>
<p>For maximum performance, the VM should support edge-enqueuing for as many objects as
practical.  Also note that this method is called for every object to be scanned, so it
must be fast.  The VM binding should avoid expensive checks and keep it as efficient as
possible.</p>
<p>Arguments:</p>
<ul>
<li><code>tls</code>: The VM-specific thread-local storage for the current worker.</li>
<li><code>object</code>: The object to be scanned.</li>
</ul>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.scan_object_and_trace_edges" class="method has-srclink"><a class="srclink rightside" href="../../../src/mmtk/vm/scanning.rs.html#181-187">source</a><h4 class="code-header">fn <a href="#method.scan_object_and_trace_edges" class="fnname">scan_object_and_trace_edges</a>&lt;OT:&nbsp;<a class="trait" href="trait.ObjectTracer.html" title="trait mmtk::vm::scanning::ObjectTracer">ObjectTracer</a>&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;_tls: <a class="struct" href="../../util/opaque_pointer/struct.VMWorkerThread.html" title="struct mmtk::util::opaque_pointer::VMWorkerThread">VMWorkerThread</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;_object: <a class="struct" href="../../util/address/struct.ObjectReference.html" title="struct mmtk::util::address::ObjectReference">ObjectReference</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;_object_tracer: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;mut </a>OT<br>)</h4></section></summary><div class="docblock"><p>Delegated scanning of a object, visiting each reference field encountered, and trace the
objects pointed by each field.</p>
<p>The VM shall call <code>object_tracer.trace_object</code> on the value held in each reference field,
and assign the returned value back to the field.  If the VM uses tagged references, the
value passed to <code>object_tracer.trace_object</code> shall be the <code>ObjectReference</code> to the object
without any tag bits.</p>
<p>The VM may skip a reference field if it holds a null reference.  If the VM supports tagged
references, it must skip tagged reference fields which are not holding references.</p>
<p>The <code>memory_manager::is_mmtk_object</code> function can be used in this function if</p>
<ul>
<li>the “is_mmtk_object” feature is enabled, and</li>
<li><code>VM::VMObjectModel::NEED_VO_BITS_DURING_TRACING</code> is true.</li>
</ul>
<p>Arguments:</p>
<ul>
<li><code>tls</code>: The VM-specific thread-local storage for the current worker.</li>
<li><code>object</code>: The object to be scanned.</li>
<li><code>object_tracer</code>: Called back for the content of each edge.</li>
</ul>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.process_weak_refs" class="method has-srclink"><a class="srclink rightside" href="../../../src/mmtk/vm/scanning.rs.html#285-290">source</a><h4 class="code-header">fn <a href="#method.process_weak_refs" class="fnname">process_weak_refs</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;_worker: &amp;mut <a class="struct" href="../../scheduler/worker/struct.GCWorker.html" title="struct mmtk::scheduler::worker::GCWorker">GCWorker</a>&lt;VM&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;_tracer_context: impl <a class="trait" href="trait.ObjectTracerContext.html" title="trait mmtk::vm::scanning::ObjectTracerContext">ObjectTracerContext</a>&lt;VM&gt;<br>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Process weak references.</p>
<p>This function is called after a transitive closure is completed.</p>
<p>MMTk core enables the VM binding to do the following in this function:</p>
<ol>
<li>Query if an object is already reached in this transitive closure.</li>
<li>Keep certain objects and their descendents alive.</li>
<li>Get the new address of objects that are either
<ul>
<li>already alive before this function is called, or</li>
<li>explicitly kept alive in this function.</li>
</ul>
</li>
<li>Request this function to be called again after transitive closure is finished again.</li>
</ol>
<p>The VM binding can call <code>ObjectReference::is_reachable()</code> to query if an object is
currently reached.</p>
<p>The VM binding can use <code>tracer_factory</code> to get access to an <code>ObjectTracer</code>, and call
its <code>trace_object(object)</code> method to keep <code>object</code> and its decendents alive.</p>
<p>The return value of <code>ObjectTracer::trace_object(object)</code> is the new address of the given
<code>object</code> if it is moved by the GC.</p>
<p>The VM binding can return <code>true</code> from <code>process_weak_refs</code> to request <code>process_weak_refs</code>
to be called again after the MMTk core finishes transitive closure again from the objects
newly visited by <code>ObjectTracer::trace_object</code>.  This is useful if a VM supports multiple
levels of reachabilities (such as Java) or ephemerons.</p>
<p>Implementation-wise, this function is called as the “sentinel” of the <code>VMRefClosure</code> work
bucket, which means it is called when all work packets in that bucket have finished.  The
<code>tracer_factory</code> expands the transitive closure by adding more work packets in the same
bucket.  This means if <code>process_weak_refs</code> returns true, those work packets will have
finished (completing the transitive closure) by the time <code>process_weak_refs</code> is called
again.  The VM binding can make use of this by adding custom work packets into the
<code>VMRefClosure</code> bucket.  The bucket will be <code>VMRefForwarding</code>, instead, when forwarding.
See below.</p>
<p>The <code>memory_manager::is_mmtk_object</code> function can be used in this function if</p>
<ul>
<li>the “is_mmtk_object” feature is enabled, and</li>
<li><code>VM::VMObjectModel::NEED_VO_BITS_DURING_TRACING</code> is true.</li>
</ul>
<p>Arguments:</p>
<ul>
<li><code>worker</code>: The current GC worker.</li>
<li><code>tracer_context</code>: Use this to get access an <code>ObjectTracer</code> and use it to retain and
update weak references.</li>
</ul>
<p>This function shall return true if this function needs to be called again after the GC
finishes expanding the transitive closure from the objects kept alive.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.forward_weak_refs" class="method has-srclink"><a class="srclink rightside" href="../../../src/mmtk/vm/scanning.rs.html#302-306">source</a><h4 class="code-header">fn <a href="#method.forward_weak_refs" class="fnname">forward_weak_refs</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;_worker: &amp;mut <a class="struct" href="../../scheduler/worker/struct.GCWorker.html" title="struct mmtk::scheduler::worker::GCWorker">GCWorker</a>&lt;VM&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;_tracer_context: impl <a class="trait" href="trait.ObjectTracerContext.html" title="trait mmtk::vm::scanning::ObjectTracerContext">ObjectTracerContext</a>&lt;VM&gt;<br>)</h4></section></summary><div class="docblock"><p>Forward weak references.</p>
<p>This function will only be called in the forwarding stage when using the mark-compact GC
algorithm.  Mark-compact computes transive closure twice during each GC.  It marks objects
in the first transitive closure, and forward references in the second transitive closure.</p>
<p>Arguments:</p>
<ul>
<li><code>worker</code>: The current GC worker.</li>
<li><code>tracer_context</code>: Use this to get access an <code>ObjectTracer</code> and use it to update weak
references.</li>
</ul>
</div></details></div><h2 id="implementors" class="small-section-header">Implementors<a href="#implementors" class="anchor"></a></h2><div id="implementors-list"></div><script src="../../../implementors/mmtk/vm/scanning/trait.Scanning.js" async></script></section></div></main><div id="rustdoc-vars" data-root-path="../../../" data-current-crate="mmtk" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.66.1 (90743e729 2023-01-10)" ></div></body></html>