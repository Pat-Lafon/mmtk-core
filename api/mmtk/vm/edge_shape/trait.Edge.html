<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="An `Edge` represents a slot in an object (a.k.a. a field), on the stack (i.e. a local variable) or any other places (such as global variables).  A slot may hold an object reference. We can load the object reference from it, and we can store an ObjectReference into it.  For some VMs, a slot may sometimes not hold an object reference.  For example, it can hold a special `NULL` pointer which does not point to any object, or it can hold a tagged non-reference value, such as small integers and special values such as `true`, `false`, `null` (a.k.a. “none”, “nil”, etc. for other VMs), `undefined`, etc."><title>Edge in mmtk::vm::edge_shape - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../static.files/rustdoc-f3501f0f5ae15dfb.css" id="mainThemeStyle"><div id="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="mmtk" data-themes="" data-resource-suffix="" data-rustdoc-version="1.71.1 (eb26296b5 2023-08-03)" data-search-js="search-4926e5fc22a5646a.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-0f8c037637f9eb3e.css" data-theme-dark-css="dark-1097f8e92a01e3cf.css" data-theme-ayu-css="ayu-614652228113ac93.css" ></div><script src="../../../static.files/storage-62ce34ea385b278a.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../static.files/main-f0540c1d82cde29b.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../../../static.files/light-0f8c037637f9eb3e.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../../../static.files/dark-1097f8e92a01e3cf.css"><link rel="stylesheet" href="../../../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc trait"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../../../mmtk/index.html"><img class="rust-logo" src="../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../../../mmtk/index.html"><img class="rust-logo" src="../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Edge</a></h2><div class="sidebar-elems"><section><h3><a href="#required-methods">Required Methods</a></h3><ul class="block"><li><a href="#tymethod.load">load</a></li><li><a href="#tymethod.store">store</a></li></ul><h3><a href="#provided-methods">Provided Methods</a></h3><ul class="block"><li><a href="#method.prefetch_load">prefetch_load</a></li><li><a href="#method.prefetch_store">prefetch_store</a></li></ul><h3><a href="#implementors">Implementors</a></h3></section><h2><a href="index.html">In mmtk::vm::edge_shape</a></h2></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Trait <a href="../../index.html">mmtk</a>::<wbr><a href="../index.html">vm</a>::<wbr><a href="index.html">edge_shape</a>::<wbr><a class="trait" href="#">Edge</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../../../src/mmtk/vm/edge_shape.rs.html#47-84">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub trait Edge: <a class="trait" href="https://doc.rust-lang.org/1.71.1/core/marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a> + <a class="trait" href="https://doc.rust-lang.org/1.71.1/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/1.71.1/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> + <a class="trait" href="https://doc.rust-lang.org/1.71.1/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a> + <a class="trait" href="https://doc.rust-lang.org/1.71.1/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> + <a class="trait" href="https://doc.rust-lang.org/1.71.1/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a> {
    // Required methods
    fn <a href="#tymethod.load" class="fn">load</a>(&amp;self) -&gt; <a class="struct" href="../../util/address/struct.ObjectReference.html" title="struct mmtk::util::address::ObjectReference">ObjectReference</a>;
<span class="item-spacer"></span>    fn <a href="#tymethod.store" class="fn">store</a>(&amp;self, object: <a class="struct" href="../../util/address/struct.ObjectReference.html" title="struct mmtk::util::address::ObjectReference">ObjectReference</a>);

    // Provided methods
    fn <a href="#method.prefetch_load" class="fn">prefetch_load</a>(&amp;self) { ... }
<span class="item-spacer"></span>    fn <a href="#method.prefetch_store" class="fn">prefetch_store</a>(&amp;self) { ... }
}</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>An <code>Edge</code> represents a slot in an object (a.k.a. a field), on the stack (i.e. a local variable)
or any other places (such as global variables).  A slot may hold an object reference. We can
load the object reference from it, and we can store an ObjectReference into it.  For some VMs,
a slot may sometimes not hold an object reference.  For example, it can hold a special <code>NULL</code>
pointer which does not point to any object, or it can hold a tagged non-reference value, such
as small integers and special values such as <code>true</code>, <code>false</code>, <code>null</code> (a.k.a. “none”, “nil”,
etc. for other VMs), <code>undefined</code>, etc.</p>
<p>This intends to abstract out the differences of reference field representation among different
VMs.  If the VM represent a reference field as a word that holds the pointer to the object, it
can use the default <code>SimpleEdge</code> we provide.  In some cases, the VM need to implement its own
<code>Edge</code> instances.</p>
<p>For example:</p>
<ul>
<li>The VM uses compressed pointer (Compressed OOP in OpenJDK’s terminology), where the heap
size is limited, and a 64-bit pointer is stored in a 32-bit slot.</li>
<li>The VM uses tagged pointer, where some bits of a word are used as metadata while the rest
are used as pointer.</li>
<li>A field holds a pointer to the middle of an object (an object field, or an array element,
or some arbitrary offset) for some reasons.</li>
</ul>
<p>When loading, <code>Edge::load</code> shall decode its internal representation to a “regular”
<code>ObjectReference</code>.  The implementation
can do this with any appropriate operations, usually shifting and masking bits or subtracting
offset from the address.  By doing this conversion, MMTk can implement GC algorithms in a
VM-neutral way, knowing only <code>ObjectReference</code>.</p>
<p>When GC moves object, <code>Edge::store</code> shall convert the updated <code>ObjectReference</code> back to the
edge-specific representation.  Compressed pointers remain compressed; tagged pointers preserve
their tag bits; and offsetted pointers keep their offsets.</p>
<p>The methods of this trait are called on hot paths.  Please ensure they have high performance.
Use inlining when appropriate.</p>
<p>Note: this trait only concerns the representation (i.e. the shape) of the edge, not its
semantics, such as whether it holds strong or weak references.  If a VM holds a weak reference
in a word as a pointer, it can also use <code>SimpleEdge</code> for weak reference fields.</p>
</div></details><h2 id="required-methods" class="small-section-header">Required Methods<a href="#required-methods" class="anchor">§</a></h2><div class="methods"><details class="toggle method-toggle" open><summary><section id="tymethod.load" class="method"><a class="srclink rightside" href="../../../src/mmtk/vm/edge_shape.rs.html#56">source</a><h4 class="code-header">fn <a href="#tymethod.load" class="fn">load</a>(&amp;self) -&gt; <a class="struct" href="../../util/address/struct.ObjectReference.html" title="struct mmtk::util::address::ObjectReference">ObjectReference</a></h4></section></summary><div class="docblock"><p>Load object reference from the slot.</p>
<p>If the slot is not holding an object reference (For example, if it is holding NULL or a
tagged non-reference value.  See trait-level doc comment.), this method should return
<code>ObjectReference::NULL</code>.</p>
<p>If the slot holds an object reference with tag bits, the returned value shall be the object
reference with the tag bits removed.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.store" class="method"><a class="srclink rightside" href="../../../src/mmtk/vm/edge_shape.rs.html#73">source</a><h4 class="code-header">fn <a href="#tymethod.store" class="fn">store</a>(&amp;self, object: <a class="struct" href="../../util/address/struct.ObjectReference.html" title="struct mmtk::util::address::ObjectReference">ObjectReference</a>)</h4></section></summary><div class="docblock"><p>Store the object reference <code>object</code> into the slot.</p>
<p>If the slot holds an object reference with tag bits, this method must preserve the tag
bits while updating the object reference so that it points to the forwarded object given by
the parameter <code>object</code>.</p>
<p>FIXME: This design is inefficient for handling object references with tag bits.  Consider
introducing a new updating function to do the load, trace and store in one function.
See: <a href="https://github.com/mmtk/mmtk-core/issues/1033">https://github.com/mmtk/mmtk-core/issues/1033</a></p>
<p>FIXME: This method is currently used by both moving GC algorithms and the subsuming write
barrier (<a href="../../memory_manager/fn.object_reference_write.html" title="fn mmtk::memory_manager::object_reference_write"><code>crate::memory_manager::object_reference_write</code></a>).  The two reference writing
operations have different semantics, and need to be implemented differently if the VM
supports offsetted or tagged references.
See: <a href="https://github.com/mmtk/mmtk-core/issues/1038">https://github.com/mmtk/mmtk-core/issues/1038</a></p>
</div></details></div><h2 id="provided-methods" class="small-section-header">Provided Methods<a href="#provided-methods" class="anchor">§</a></h2><div class="methods"><details class="toggle method-toggle" open><summary><section id="method.prefetch_load" class="method"><a class="srclink rightside" href="../../../src/mmtk/vm/edge_shape.rs.html#76-78">source</a><h4 class="code-header">fn <a href="#method.prefetch_load" class="fn">prefetch_load</a>(&amp;self)</h4></section></summary><div class="docblock"><p>Prefetch the edge so that a subsequent <code>load</code> will be faster.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.prefetch_store" class="method"><a class="srclink rightside" href="../../../src/mmtk/vm/edge_shape.rs.html#81-83">source</a><h4 class="code-header">fn <a href="#method.prefetch_store" class="fn">prefetch_store</a>(&amp;self)</h4></section></summary><div class="docblock"><p>Prefetch the edge so that a subsequent <code>store</code> will be faster.</p>
</div></details></div><h2 id="implementors" class="small-section-header">Implementors<a href="#implementors" class="anchor">§</a></h2><div id="implementors-list"><section id="impl-Edge-for-Address" class="impl"><a class="srclink rightside" href="../../../src/mmtk/vm/edge_shape.rs.html#135-143">source</a><a href="#impl-Edge-for-Address" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="trait.Edge.html" title="trait mmtk::vm::edge_shape::Edge">Edge</a> for <a class="struct" href="../../util/address/struct.Address.html" title="struct mmtk::util::address::Address">Address</a></h3></section><div class="docblock"><p>For backword compatibility, we let <code>Address</code> implement <code>Edge</code> so that existing bindings that
use <code>Address</code> to represent an edge can continue to work.</p>
<p>However, we should use <code>SimpleEdge</code> directly instead of using <code>Address</code>.  The purpose of the
<code>Address</code> type is to represent an address in memory.  It is not directly related to fields
that hold references to other objects.  Calling <code>load()</code> and <code>store()</code> on an <code>Address</code> does
not indicate how many bytes to load or store, or how to interpret those bytes.  On the other
hand, <code>SimpleEdge</code> is all about how to access a field that holds a reference represented
simply as an <code>ObjectReference</code>.  The intention and the semantics are clearer with
<code>SimpleEdge</code>.</p>
</div><section id="impl-Edge-for-SimpleEdge" class="impl"><a class="srclink rightside" href="../../../src/mmtk/vm/edge_shape.rs.html#115-123">source</a><a href="#impl-Edge-for-SimpleEdge" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="trait.Edge.html" title="trait mmtk::vm::edge_shape::Edge">Edge</a> for <a class="struct" href="struct.SimpleEdge.html" title="struct mmtk::vm::edge_shape::SimpleEdge">SimpleEdge</a></h3></section></div><script src="../../../implementors/mmtk/vm/edge_shape/trait.Edge.js" async></script></section></div></main></body></html>