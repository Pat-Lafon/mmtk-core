<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="VM-to-MMTk interface: safe Rust APIs."><meta name="keywords" content="rust, rustlang, rust-lang, memory_manager"><title>mmtk::memory_manager - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../ayu.css" disabled><link rel="stylesheet" type="text/css" href="../../dark.css" disabled><link rel="stylesheet" type="text/css" href="../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../storage.js"></script><script src="../../crates.js"></script><script defer src="../../main.js"></script>
    <noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../favicon.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a class="sidebar-logo" href="../../mmtk/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.png" alt="logo"></div>
        </a><h2 class="location">Module memory_manager</h2><div class="sidebar-elems"><div class="block items"><ul><li><a href="#functions">Functions</a></li></ul></div><div id="sidebar-vars" data-name="memory_manager" data-ty="mod" data-relpath="./"></div><script defer src="./sidebar-items.js"></script></div></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../../mmtk/index.html"><img class="rust-logo" src="../../rust-logo.png" alt="logo"></a><nav class="sub"><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="18" height="18" alt="Pick another theme!" src="../../brush.svg"></button><div id="theme-choices" role="menu"></div></div><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../../settings.html" title="settings"><img width="18" height="18" alt="Change settings" src="../../wheel.svg"></a></div></form></nav></div><section id="main-content" class="content"><h1 class="fqn"><span class="in-band">Module <a href="../index.html">mmtk</a>::<wbr><a class="mod" href="#">memory_manager</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../../src/mmtk/memory_manager.rs.html#1-702" title="goto source code">[src]</a></span></h1><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>VM-to-MMTk interface: safe Rust APIs.</p>
<p>This module provides a safe Rust API for mmtk-core.
We expect the VM binding to inherit and extend this API by:</p>
<ol>
<li>adding their VM-specific functions</li>
<li>exposing the functions to native if necessary. And the VM binding needs to manage the unsafety
for exposing this safe API to FFI.</li>
</ol>
<p>For example, for mutators, this API provides a <code>Box&lt;Mutator&gt;</code>, and requires a <code>&amp;mut Mutator</code> for allocation.
A VM binding can borrow a mutable reference directly from <code>Box&lt;Mutator&gt;</code>, and call <code>alloc()</code>. Alternatively,
it can turn the <code>Box</code> pointer to a native pointer (<code>*mut Mutator</code>), and forge a mut reference from the native
pointer. Either way, the VM binding code needs to guarantee the safety.</p>
</div></details><h2 id="functions" class="small-section-header"><a href="#functions">Functions</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.add_finalizer.html" title="mmtk::memory_manager::add_finalizer fn">add_finalizer</a></div><div class="item-right docblock-short"><p>Register a finalizable object. MMTk will retain the liveness of
the object even if it is not reachable from the program.
Note that finalization upon exit is not supported.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.add_phantom_candidate.html" title="mmtk::memory_manager::add_phantom_candidate fn">add_phantom_candidate</a></div><div class="item-right docblock-short"><p>Add a reference to the list of phantom references. A binding may
call this either when a weak reference is created, or when a weak reference is traced during GC.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.add_soft_candidate.html" title="mmtk::memory_manager::add_soft_candidate fn">add_soft_candidate</a></div><div class="item-right docblock-short"><p>Add a reference to the list of soft references. A binding may
call this either when a weak reference is created, or when a weak reference is traced during GC.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.add_weak_candidate.html" title="mmtk::memory_manager::add_weak_candidate fn">add_weak_candidate</a></div><div class="item-right docblock-short"><p>Add a reference to the list of weak references. A binding may
call this either when a weak reference is created, or when a weak reference is traced during GC.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.add_work_packet.html" title="mmtk::memory_manager::add_work_packet fn">add_work_packet</a></div><div class="item-right docblock-short"><p>Add a work packet to the given work bucket. Note that this simply adds the work packet to the given
work bucket, and the scheduler will decide when to execute the work packet.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.add_work_packets.html" title="mmtk::memory_manager::add_work_packets fn">add_work_packets</a></div><div class="item-right docblock-short"><p>Bulk add a number of work packets to the given work bucket. Note that this simply adds the work packets
to the given work bucket, and the scheduler will decide when to execute the work packets.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.alloc.html" title="mmtk::memory_manager::alloc fn">alloc</a></div><div class="item-right docblock-short"><p>Allocate memory for an object. For performance reasons, a VM should
implement the allocation fast-path on their side rather than just calling this function.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.bind_mutator.html" title="mmtk::memory_manager::bind_mutator fn">bind_mutator</a></div><div class="item-right docblock-short"><p>Request MMTk to create a mutator for the given thread. For performance reasons, A VM should
store the returned mutator in a thread local storage that can be accessed efficiently.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.calloc.html" title="mmtk::memory_manager::calloc fn">calloc</a></div><div class="item-right docblock-short"><p>The standard calloc.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.counted_calloc.html" title="mmtk::memory_manager::counted_calloc fn">counted_calloc</a></div><div class="item-right docblock-short"><p>The standard calloc except that with the feature <code>malloc_counted_size</code>, MMTk will count the allocated memory into its heap size.
Thus the method requires a reference to an MMTk instance.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.counted_malloc.html" title="mmtk::memory_manager::counted_malloc fn">counted_malloc</a></div><div class="item-right docblock-short"><p>The standard malloc except that with the feature <code>malloc_counted_size</code>, MMTk will count the allocated memory into its heap size.
Thus the method requires a reference to an MMTk instance. MMTk either uses its own allocator, or forward the call to a
library malloc.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.destroy_mutator.html" title="mmtk::memory_manager::destroy_mutator fn">destroy_mutator</a></div><div class="item-right docblock-short"><p>Reclaim a mutator that is no longer needed.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.disable_collection.html" title="mmtk::memory_manager::disable_collection fn">disable_collection</a></div><div class="item-right docblock-short"><p>Disallow MMTk to trigger garbage collection. When collection is disabled, you can still allocate through MMTk. But MMTk will
not trigger a GC even if the heap is full. In such a case, the allocation will exceed the MMTk’s heap size (the soft heap limit).
However, there is no guarantee that the physical allocation will succeed, and if it succeeds, there is no guarantee that further allocation
will keep succeeding. So if a VM disables collection, it needs to allocate with careful consideration to make sure that the physical memory
allows the amount of allocation. We highly recommend not using this method. However, we support this to accomodate some VMs that require this
behavior. This call does not disable explicit GCs (through handle_user_collection_request()).
Note this call is not thread safe, only one VM thread should call this.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.enable_collection.html" title="mmtk::memory_manager::enable_collection fn">enable_collection</a></div><div class="item-right docblock-short"><p>Allow MMTk to trigger garbage collection when heap is full. This should only be used in pair with disable_collection().
See the comments on disable_collection(). If disable_collection() is not used, there is no need to call this function at all.
Note this call is not thread safe, only one VM thread should call this.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.flush_mutator.html" title="mmtk::memory_manager::flush_mutator fn">flush_mutator</a></div><div class="item-right docblock-short"><p>Flush the mutator’s local states.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.free.html" title="mmtk::memory_manager::free fn">free</a></div><div class="item-right docblock-short"><p>The standard free.
The <code>addr</code> in the arguments must be an address that is earlier returned from MMTk’s <code>malloc()</code>, <code>calloc()</code> or <code>realloc()</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.free_bytes.html" title="mmtk::memory_manager::free_bytes fn">free_bytes</a></div><div class="item-right docblock-short"><p>Return free memory in bytes.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.free_with_size.html" title="mmtk::memory_manager::free_with_size fn">free_with_size</a></div><div class="item-right docblock-short"><p>The standard free except that with the feature <code>malloc_counted_size</code>, MMTk will count the allocated memory into its heap size.
Thus the method requires a reference to an MMTk instance, and the size of the memory to free.
The <code>addr</code> in the arguments must be an address that is earlier returned from MMTk’s <code>malloc()</code>, <code>calloc()</code> or <code>realloc()</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.gc_poll.html" title="mmtk::memory_manager::gc_poll fn">gc_poll</a></div><div class="item-right docblock-short"><p>Poll for GC. MMTk will decide if a GC is needed. If so, this call will block
the current thread, and trigger a GC. Otherwise, it will simply return.
Usually a binding does not need to call this function. MMTk will poll for GC during its allocation.
However, if a binding uses counted malloc (which won’t poll for GC), they may want to poll for GC manually.
This function should only be used by mutator threads.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.get_all_finalizers.html" title="mmtk::memory_manager::get_all_finalizers fn">get_all_finalizers</a></div><div class="item-right docblock-short"><p>Pop all the finalizers that were registered for finalization. The returned objects may or may not be ready for
finalization. After this call, MMTk’s finalizer processor should have no registered finalizer any more.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.get_allocator_mapping.html" title="mmtk::memory_manager::get_allocator_mapping fn">get_allocator_mapping</a></div><div class="item-right docblock-short"><p>Return an AllocatorSelector for the given allocation semantic. This method is provided
so that VM compilers may call it to help generate allocation fast-path.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.get_finalized_object.html" title="mmtk::memory_manager::get_finalized_object fn">get_finalized_object</a></div><div class="item-right docblock-short"><p>Get an object that is ready for finalization. After each GC, if any registered object is not
alive, this call will return one of the objects. MMTk will retain the liveness of those objects
until they are popped through this call. Once an object is popped, it is the responsibility of
the VM to make sure they are properly finalized before reclaimed by the GC. This call is non-blocking,
and will return None if no object is ready for finalization.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.get_finalizers_for.html" title="mmtk::memory_manager::get_finalizers_for fn">get_finalizers_for</a></div><div class="item-right docblock-short"><p>Pop finalizers that were registered and associated with a certain object. The returned objects may or may not be ready for finalization.
This is useful for some VMs that may manually execute finalize method for an object.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.handle_user_collection_request.html" title="mmtk::memory_manager::handle_user_collection_request fn">handle_user_collection_request</a></div><div class="item-right docblock-short"><p>Trigger a garbage collection as requested by the user.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.harness_begin.html" title="mmtk::memory_manager::harness_begin fn">harness_begin</a></div><div class="item-right docblock-short"><p>Generic hook to allow benchmarks to be harnessed. We do a full heap
GC, and then start recording statistics for MMTk.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.harness_end.html" title="mmtk::memory_manager::harness_end fn">harness_end</a></div><div class="item-right docblock-short"><p>Generic hook to allow benchmarks to be harnessed. We stop collecting
statistics, and print stats values.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.initialize_collection.html" title="mmtk::memory_manager::initialize_collection fn">initialize_collection</a></div><div class="item-right docblock-short"><p>Initialize the scheduler and GC workers that are required for doing garbage collections.
This is a mandatory call for a VM during its boot process once its thread system
is ready. This should only be called once. This call will invoke Collection::spawn_gc_thread()
to create GC threads.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.is_in_mmtk_spaces.html" title="mmtk::memory_manager::is_in_mmtk_spaces fn">is_in_mmtk_spaces</a></div><div class="item-right docblock-short"><p>Return true if the <code>object</code> lies in a region of memory where</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.is_live_object.html" title="mmtk::memory_manager::is_live_object fn">is_live_object</a></div><div class="item-right docblock-short"><p>Is the object alive?</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.is_mapped_address.html" title="mmtk::memory_manager::is_mapped_address fn">is_mapped_address</a></div><div class="item-right docblock-short"><p>Is the address in the mapped memory? The runtime can use this function to check
if an address is mapped by MMTk. Note that this is different than is_in_mmtk_spaces().
For malloc spaces, MMTk does not map those addresses (malloc does the mmap), so
this function will return false, but is_in_mmtk_spaces will return true if the address
is actually a valid object in malloc spaces. To check if an object is in our heap,
the runtime should always use is_in_mmtk_spaces(). This function is_mapped_address()
may get removed at some point.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.is_mmtk_object.html" title="mmtk::memory_manager::is_mmtk_object fn">is_mmtk_object</a></div><div class="item-right docblock-short"><p>Check if <code>addr</code> is the address of an object reference to an MMTk object.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.last_heap_address.html" title="mmtk::memory_manager::last_heap_address fn">last_heap_address</a></div><div class="item-right docblock-short"><p>Return the ending address of the heap. <em>Note that currently MMTk uses
a fixed address range as heap.</em></p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.malloc.html" title="mmtk::memory_manager::malloc fn">malloc</a></div><div class="item-right docblock-short"><p>The standard malloc. MMTk either uses its own allocator, or forward the call to a
library malloc.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.mmtk_init.html" title="mmtk::memory_manager::mmtk_init fn">mmtk_init</a></div><div class="item-right docblock-short"><p>Initialize an MMTk instance. A VM should call this method after creating an <a href="../mmtk/struct.MMTK.html">MMTK</a>
instance but before using any of the methods provided in MMTk (except <code>process()</code> and <code>process_bulk()</code>).</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.modify_check.html" title="mmtk::memory_manager::modify_check fn">modify_check</a></div><div class="item-right docblock-short"><p>Check that if a garbage collection is in progress and if the given
object is not movable.  If it is movable error messages are
logged and the system exits.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.num_of_workers.html" title="mmtk::memory_manager::num_of_workers fn">num_of_workers</a></div><div class="item-right docblock-short"><p>Get the number of workers. MMTk spawns worker threads for the ‘threads’ defined in the options.
So the number of workers is derived from the threads option. Note the feature single_worker overwrites
the threads option, and force one worker thread.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.on_closure_end.html" title="mmtk::memory_manager::on_closure_end fn">on_closure_end</a></div><div class="item-right docblock-short"><p>Add a callback to be notified after the transitive closure is finished.
The callback should return true if it add more work packets to the closure bucket.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.post_alloc.html" title="mmtk::memory_manager::post_alloc fn">post_alloc</a></div><div class="item-right docblock-short"><p>Perform post-allocation actions, usually initializing object metadata. For many allocators none are
required. For performance reasons, a VM should implement the post alloc fast-path on their side
rather than just calling this function.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.post_write_barrier.html" title="mmtk::memory_manager::post_write_barrier fn">post_write_barrier</a></div><div class="item-right docblock-short"><p>The write barrier by MMTk. This is a <em>post</em> write barrier, which we expect a binding to call
<em>after</em> they modify an object. For performance reasons, a VM should implement the write barrier
fast-path on their side rather than just calling this function.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.process.html" title="mmtk::memory_manager::process fn">process</a></div><div class="item-right docblock-short"><p>Process MMTk run-time options. Returns true if the option is processed successfully.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.process_bulk.html" title="mmtk::memory_manager::process_bulk fn">process_bulk</a></div><div class="item-right docblock-short"><p>Process multiple MMTk run-time options. Returns true if all the options are processed successfully.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.realloc.html" title="mmtk::memory_manager::realloc fn">realloc</a></div><div class="item-right docblock-short"><p>The standard realloc.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.realloc_with_old_size.html" title="mmtk::memory_manager::realloc_with_old_size fn">realloc_with_old_size</a></div><div class="item-right docblock-short"><p>The standard realloc except that with the feature <code>malloc_counted_size</code>, MMTk will count the allocated memory into its heap size.
Thus the method requires a reference to an MMTk instance, and the size of the existing memory that will be reallocated.
The <code>addr</code> in the arguments must be an address that is earlier returned from MMTk’s <code>malloc()</code>, <code>calloc()</code> or <code>realloc()</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.start_control_collector.html" title="mmtk::memory_manager::start_control_collector fn">start_control_collector</a></div><div class="item-right docblock-short"><p>Run the main loop for the GC controller thread. This method does not return.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.start_worker.html" title="mmtk::memory_manager::start_worker fn">start_worker</a></div><div class="item-right docblock-short"><p>Run the main loop of a GC worker. This method does not return.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.starting_heap_address.html" title="mmtk::memory_manager::starting_heap_address fn">starting_heap_address</a></div><div class="item-right docblock-short"><p>Return the starting address of the heap. <em>Note that currently MMTk uses
a fixed address range as heap.</em></p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.total_bytes.html" title="mmtk::memory_manager::total_bytes fn">total_bytes</a></div><div class="item-right docblock-short"><p>Return the total memory in bytes.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.used_bytes.html" title="mmtk::memory_manager::used_bytes fn">used_bytes</a></div><div class="item-right docblock-short"><p>Return used memory in bytes.</p>
</div></div></div></section><section id="search" class="content hidden"></section></div></main><div id="rustdoc-vars" data-root-path="../../" data-current-crate="mmtk" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.59.0 (9d1b2106e 2022-02-23)" ></div>
</body></html>