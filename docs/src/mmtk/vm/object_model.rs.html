<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `src&#x2F;vm&#x2F;object_model.rs`."><meta name="keywords" content="rust, rustlang, rust-lang"><title>object_model.rs - source</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" type="text/css" href="../../../normalize.css"><link rel="stylesheet" type="text/css" href="../../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../../ayu.css" disabled><link rel="stylesheet" type="text/css" href="../../../dark.css" disabled><link rel="stylesheet" type="text/css" href="../../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../../storage.js"></script><script src="../../../crates.js"></script><script defer src="../../../main.js"></script><script defer src="../../../source-script.js"></script><script defer src="../../../source-files.js"></script>
    <noscript><link rel="stylesheet" href="../../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../../favicon.svg"></head><body class="rustdoc source"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a class="sidebar-logo" href="../../../mmtk/index.html"><div class="logo-container"><img class="rust-logo" src="../../../rust-logo.png" alt="logo"></div>
        </a></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../../../mmtk/index.html"><img class="rust-logo" src="../../../rust-logo.png" alt="logo"></a><nav class="sub"><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="18" height="18" alt="Pick another theme!" src="../../../brush.svg"></button><div id="theme-choices" role="menu"></div></div><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../../../settings.html" title="settings"><img width="18" height="18" alt="Change settings" src="../../../wheel.svg"></a></div></form></nav></div><section id="main-content" class="content"><div class="example-wrap"><pre class="line-numbers"><span id="1">  1</span>
<span id="2">  2</span>
<span id="3">  3</span>
<span id="4">  4</span>
<span id="5">  5</span>
<span id="6">  6</span>
<span id="7">  7</span>
<span id="8">  8</span>
<span id="9">  9</span>
<span id="10"> 10</span>
<span id="11"> 11</span>
<span id="12"> 12</span>
<span id="13"> 13</span>
<span id="14"> 14</span>
<span id="15"> 15</span>
<span id="16"> 16</span>
<span id="17"> 17</span>
<span id="18"> 18</span>
<span id="19"> 19</span>
<span id="20"> 20</span>
<span id="21"> 21</span>
<span id="22"> 22</span>
<span id="23"> 23</span>
<span id="24"> 24</span>
<span id="25"> 25</span>
<span id="26"> 26</span>
<span id="27"> 27</span>
<span id="28"> 28</span>
<span id="29"> 29</span>
<span id="30"> 30</span>
<span id="31"> 31</span>
<span id="32"> 32</span>
<span id="33"> 33</span>
<span id="34"> 34</span>
<span id="35"> 35</span>
<span id="36"> 36</span>
<span id="37"> 37</span>
<span id="38"> 38</span>
<span id="39"> 39</span>
<span id="40"> 40</span>
<span id="41"> 41</span>
<span id="42"> 42</span>
<span id="43"> 43</span>
<span id="44"> 44</span>
<span id="45"> 45</span>
<span id="46"> 46</span>
<span id="47"> 47</span>
<span id="48"> 48</span>
<span id="49"> 49</span>
<span id="50"> 50</span>
<span id="51"> 51</span>
<span id="52"> 52</span>
<span id="53"> 53</span>
<span id="54"> 54</span>
<span id="55"> 55</span>
<span id="56"> 56</span>
<span id="57"> 57</span>
<span id="58"> 58</span>
<span id="59"> 59</span>
<span id="60"> 60</span>
<span id="61"> 61</span>
<span id="62"> 62</span>
<span id="63"> 63</span>
<span id="64"> 64</span>
<span id="65"> 65</span>
<span id="66"> 66</span>
<span id="67"> 67</span>
<span id="68"> 68</span>
<span id="69"> 69</span>
<span id="70"> 70</span>
<span id="71"> 71</span>
<span id="72"> 72</span>
<span id="73"> 73</span>
<span id="74"> 74</span>
<span id="75"> 75</span>
<span id="76"> 76</span>
<span id="77"> 77</span>
<span id="78"> 78</span>
<span id="79"> 79</span>
<span id="80"> 80</span>
<span id="81"> 81</span>
<span id="82"> 82</span>
<span id="83"> 83</span>
<span id="84"> 84</span>
<span id="85"> 85</span>
<span id="86"> 86</span>
<span id="87"> 87</span>
<span id="88"> 88</span>
<span id="89"> 89</span>
<span id="90"> 90</span>
<span id="91"> 91</span>
<span id="92"> 92</span>
<span id="93"> 93</span>
<span id="94"> 94</span>
<span id="95"> 95</span>
<span id="96"> 96</span>
<span id="97"> 97</span>
<span id="98"> 98</span>
<span id="99"> 99</span>
<span id="100">100</span>
<span id="101">101</span>
<span id="102">102</span>
<span id="103">103</span>
<span id="104">104</span>
<span id="105">105</span>
<span id="106">106</span>
<span id="107">107</span>
<span id="108">108</span>
<span id="109">109</span>
<span id="110">110</span>
<span id="111">111</span>
<span id="112">112</span>
<span id="113">113</span>
<span id="114">114</span>
<span id="115">115</span>
<span id="116">116</span>
<span id="117">117</span>
<span id="118">118</span>
<span id="119">119</span>
<span id="120">120</span>
<span id="121">121</span>
<span id="122">122</span>
<span id="123">123</span>
<span id="124">124</span>
<span id="125">125</span>
<span id="126">126</span>
<span id="127">127</span>
<span id="128">128</span>
<span id="129">129</span>
<span id="130">130</span>
<span id="131">131</span>
<span id="132">132</span>
<span id="133">133</span>
<span id="134">134</span>
<span id="135">135</span>
<span id="136">136</span>
<span id="137">137</span>
<span id="138">138</span>
<span id="139">139</span>
<span id="140">140</span>
<span id="141">141</span>
<span id="142">142</span>
<span id="143">143</span>
<span id="144">144</span>
<span id="145">145</span>
<span id="146">146</span>
<span id="147">147</span>
<span id="148">148</span>
<span id="149">149</span>
<span id="150">150</span>
<span id="151">151</span>
<span id="152">152</span>
<span id="153">153</span>
<span id="154">154</span>
<span id="155">155</span>
<span id="156">156</span>
<span id="157">157</span>
<span id="158">158</span>
<span id="159">159</span>
<span id="160">160</span>
<span id="161">161</span>
<span id="162">162</span>
<span id="163">163</span>
<span id="164">164</span>
<span id="165">165</span>
<span id="166">166</span>
<span id="167">167</span>
<span id="168">168</span>
<span id="169">169</span>
<span id="170">170</span>
<span id="171">171</span>
<span id="172">172</span>
<span id="173">173</span>
<span id="174">174</span>
<span id="175">175</span>
<span id="176">176</span>
<span id="177">177</span>
<span id="178">178</span>
<span id="179">179</span>
<span id="180">180</span>
<span id="181">181</span>
<span id="182">182</span>
<span id="183">183</span>
<span id="184">184</span>
<span id="185">185</span>
<span id="186">186</span>
<span id="187">187</span>
<span id="188">188</span>
<span id="189">189</span>
<span id="190">190</span>
<span id="191">191</span>
<span id="192">192</span>
<span id="193">193</span>
<span id="194">194</span>
<span id="195">195</span>
<span id="196">196</span>
<span id="197">197</span>
<span id="198">198</span>
<span id="199">199</span>
<span id="200">200</span>
<span id="201">201</span>
<span id="202">202</span>
<span id="203">203</span>
<span id="204">204</span>
<span id="205">205</span>
<span id="206">206</span>
<span id="207">207</span>
<span id="208">208</span>
<span id="209">209</span>
<span id="210">210</span>
<span id="211">211</span>
<span id="212">212</span>
<span id="213">213</span>
<span id="214">214</span>
<span id="215">215</span>
<span id="216">216</span>
<span id="217">217</span>
<span id="218">218</span>
<span id="219">219</span>
<span id="220">220</span>
<span id="221">221</span>
<span id="222">222</span>
<span id="223">223</span>
<span id="224">224</span>
<span id="225">225</span>
<span id="226">226</span>
<span id="227">227</span>
<span id="228">228</span>
<span id="229">229</span>
<span id="230">230</span>
<span id="231">231</span>
<span id="232">232</span>
<span id="233">233</span>
<span id="234">234</span>
<span id="235">235</span>
<span id="236">236</span>
<span id="237">237</span>
<span id="238">238</span>
<span id="239">239</span>
<span id="240">240</span>
<span id="241">241</span>
<span id="242">242</span>
<span id="243">243</span>
<span id="244">244</span>
<span id="245">245</span>
<span id="246">246</span>
<span id="247">247</span>
<span id="248">248</span>
<span id="249">249</span>
<span id="250">250</span>
<span id="251">251</span>
<span id="252">252</span>
<span id="253">253</span>
<span id="254">254</span>
<span id="255">255</span>
<span id="256">256</span>
<span id="257">257</span>
<span id="258">258</span>
<span id="259">259</span>
<span id="260">260</span>
<span id="261">261</span>
<span id="262">262</span>
<span id="263">263</span>
<span id="264">264</span>
<span id="265">265</span>
<span id="266">266</span>
<span id="267">267</span>
<span id="268">268</span>
<span id="269">269</span>
<span id="270">270</span>
<span id="271">271</span>
<span id="272">272</span>
<span id="273">273</span>
<span id="274">274</span>
<span id="275">275</span>
<span id="276">276</span>
<span id="277">277</span>
<span id="278">278</span>
<span id="279">279</span>
<span id="280">280</span>
<span id="281">281</span>
<span id="282">282</span>
<span id="283">283</span>
<span id="284">284</span>
<span id="285">285</span>
<span id="286">286</span>
<span id="287">287</span>
<span id="288">288</span>
<span id="289">289</span>
<span id="290">290</span>
<span id="291">291</span>
<span id="292">292</span>
<span id="293">293</span>
<span id="294">294</span>
<span id="295">295</span>
<span id="296">296</span>
<span id="297">297</span>
<span id="298">298</span>
<span id="299">299</span>
<span id="300">300</span>
<span id="301">301</span>
<span id="302">302</span>
<span id="303">303</span>
<span id="304">304</span>
<span id="305">305</span>
<span id="306">306</span>
<span id="307">307</span>
<span id="308">308</span>
<span id="309">309</span>
<span id="310">310</span>
<span id="311">311</span>
<span id="312">312</span>
<span id="313">313</span>
<span id="314">314</span>
<span id="315">315</span>
<span id="316">316</span>
<span id="317">317</span>
<span id="318">318</span>
<span id="319">319</span>
<span id="320">320</span>
<span id="321">321</span>
<span id="322">322</span>
<span id="323">323</span>
<span id="324">324</span>
<span id="325">325</span>
<span id="326">326</span>
<span id="327">327</span>
<span id="328">328</span>
<span id="329">329</span>
<span id="330">330</span>
<span id="331">331</span>
<span id="332">332</span>
<span id="333">333</span>
<span id="334">334</span>
<span id="335">335</span>
<span id="336">336</span>
<span id="337">337</span>
<span id="338">338</span>
<span id="339">339</span>
<span id="340">340</span>
<span id="341">341</span>
<span id="342">342</span>
<span id="343">343</span>
<span id="344">344</span>
<span id="345">345</span>
<span id="346">346</span>
<span id="347">347</span>
<span id="348">348</span>
<span id="349">349</span>
<span id="350">350</span>
<span id="351">351</span>
<span id="352">352</span>
<span id="353">353</span>
<span id="354">354</span>
<span id="355">355</span>
<span id="356">356</span>
<span id="357">357</span>
<span id="358">358</span>
<span id="359">359</span>
<span id="360">360</span>
<span id="361">361</span>
<span id="362">362</span>
<span id="363">363</span>
<span id="364">364</span>
<span id="365">365</span>
<span id="366">366</span>
<span id="367">367</span>
<span id="368">368</span>
<span id="369">369</span>
<span id="370">370</span>
<span id="371">371</span>
<span id="372">372</span>
<span id="373">373</span>
<span id="374">374</span>
<span id="375">375</span>
<span id="376">376</span>
<span id="377">377</span>
<span id="378">378</span>
<span id="379">379</span>
<span id="380">380</span>
<span id="381">381</span>
<span id="382">382</span>
<span id="383">383</span>
<span id="384">384</span>
<span id="385">385</span>
<span id="386">386</span>
<span id="387">387</span>
<span id="388">388</span>
<span id="389">389</span>
<span id="390">390</span>
<span id="391">391</span>
<span id="392">392</span>
<span id="393">393</span>
<span id="394">394</span>
<span id="395">395</span>
<span id="396">396</span>
<span id="397">397</span>
<span id="398">398</span>
<span id="399">399</span>
<span id="400">400</span>
<span id="401">401</span>
<span id="402">402</span>
<span id="403">403</span>
<span id="404">404</span>
<span id="405">405</span>
<span id="406">406</span>
<span id="407">407</span>
<span id="408">408</span>
<span id="409">409</span>
<span id="410">410</span>
<span id="411">411</span>
<span id="412">412</span>
<span id="413">413</span>
<span id="414">414</span>
<span id="415">415</span>
<span id="416">416</span>
<span id="417">417</span>
<span id="418">418</span>
<span id="419">419</span>
<span id="420">420</span>
<span id="421">421</span>
<span id="422">422</span>
<span id="423">423</span>
<span id="424">424</span>
<span id="425">425</span>
<span id="426">426</span>
<span id="427">427</span>
<span id="428">428</span>
<span id="429">429</span>
<span id="430">430</span>
<span id="431">431</span>
<span id="432">432</span>
<span id="433">433</span>
<span id="434">434</span>
<span id="435">435</span>
<span id="436">436</span>
<span id="437">437</span>
<span id="438">438</span>
<span id="439">439</span>
<span id="440">440</span>
<span id="441">441</span>
<span id="442">442</span>
<span id="443">443</span>
<span id="444">444</span>
<span id="445">445</span>
<span id="446">446</span>
<span id="447">447</span>
<span id="448">448</span>
<span id="449">449</span>
<span id="450">450</span>
<span id="451">451</span>
<span id="452">452</span>
<span id="453">453</span>
<span id="454">454</span>
<span id="455">455</span>
<span id="456">456</span>
<span id="457">457</span>
<span id="458">458</span>
<span id="459">459</span>
<span id="460">460</span>
<span id="461">461</span>
<span id="462">462</span>
<span id="463">463</span>
<span id="464">464</span>
<span id="465">465</span>
<span id="466">466</span>
<span id="467">467</span>
<span id="468">468</span>
<span id="469">469</span>
<span id="470">470</span>
<span id="471">471</span>
<span id="472">472</span>
<span id="473">473</span>
<span id="474">474</span>
<span id="475">475</span>
<span id="476">476</span>
<span id="477">477</span>
<span id="478">478</span>
<span id="479">479</span>
<span id="480">480</span>
<span id="481">481</span>
<span id="482">482</span>
<span id="483">483</span>
<span id="484">484</span>
<span id="485">485</span>
<span id="486">486</span>
<span id="487">487</span>
<span id="488">488</span>
<span id="489">489</span>
<span id="490">490</span>
<span id="491">491</span>
<span id="492">492</span>
<span id="493">493</span>
<span id="494">494</span>
<span id="495">495</span>
<span id="496">496</span>
<span id="497">497</span>
<span id="498">498</span>
<span id="499">499</span>
<span id="500">500</span>
<span id="501">501</span>
<span id="502">502</span>
<span id="503">503</span>
<span id="504">504</span>
<span id="505">505</span>
<span id="506">506</span>
<span id="507">507</span>
<span id="508">508</span>
<span id="509">509</span>
<span id="510">510</span>
<span id="511">511</span>
<span id="512">512</span>
<span id="513">513</span>
<span id="514">514</span>
<span id="515">515</span>
<span id="516">516</span>
<span id="517">517</span>
<span id="518">518</span>
<span id="519">519</span>
<span id="520">520</span>
<span id="521">521</span>
<span id="522">522</span>
<span id="523">523</span>
<span id="524">524</span>
<span id="525">525</span>
<span id="526">526</span>
<span id="527">527</span>
<span id="528">528</span>
<span id="529">529</span>
<span id="530">530</span>
<span id="531">531</span>
<span id="532">532</span>
<span id="533">533</span>
<span id="534">534</span>
<span id="535">535</span>
<span id="536">536</span>
</pre><pre class="rust"><code><span class="kw">use</span> <span class="ident">atomic::Ordering</span>;

<span class="kw">use</span> <span class="ident"><span class="self">self</span>::specs</span>::<span class="kw-2">*</span>;
<span class="kw">use</span> <span class="ident"><span class="kw">crate</span>::util::copy</span>::<span class="kw-2">*</span>;
<span class="kw">use</span> <span class="ident"><span class="kw">crate</span>::util::metadata::header_metadata::HeaderMetadataSpec</span>;
<span class="kw">use</span> <span class="ident"><span class="kw">crate</span>::util::metadata::MetadataValue</span>;
<span class="kw">use</span> <span class="ident"><span class="kw">crate</span>::util</span>::{<span class="ident">Address</span>, <span class="ident">ObjectReference</span>};
<span class="kw">use</span> <span class="ident"><span class="kw">crate</span>::vm::VMBinding</span>;

<span class="doccomment">/// VM-specific methods for object model.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// This trait includes 3 parts:</span>
<span class="doccomment">///</span>
<span class="doccomment">/// 1. Specifications for per object metadata: a binding needs to specify the location for each per object metadata spec.</span>
<span class="doccomment">///    A binding can choose between `in_header()` or `side()`, e.g. `VMGlobalLogBitSpec::side()`.</span>
<span class="doccomment">///    * in_header: a binding needs to specify the bit offset to an object reference that can be used for the per object metadata spec.</span>
<span class="doccomment">///      The actual number of bits required for a spec can be obtained from the `num_bits()` method of the spec type.</span>
<span class="doccomment">///    * side: a binding does not need to provide any specific storage for metadata in the header. Instead, MMTk</span>
<span class="doccomment">///      will use side tables to store the metadata. The following section Side Specs Layout will discuss how to correctly create</span>
<span class="doccomment">///      side metadata specs.</span>
<span class="doccomment">/// 2. In header metadata access: A binding</span>
<span class="doccomment">///    need to further define the functions with suffix _metadata about how to access the bits in the header. We provide default implementations</span>
<span class="doccomment">///    for those methods, assuming the bits in the spec are always available to MMTk. A binding could implement their</span>
<span class="doccomment">///    own routines to access the bits if VM specific treatment is needed (e.g. some bits are not always available to MMTk).</span>
<span class="doccomment">/// 3. VM-specific object info needed by MMTk: MMTk does not know object info as it is VM specific. However, MMTk needs</span>
<span class="doccomment">///    some object information for GC. A binding needs to implement them correctly.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Note that depending on the selected GC plan, only a subset of the methods provided here will be used.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Side Specs Layout</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Short version</span>
<span class="doccomment">///</span>
<span class="doccomment">/// * For *global* side metadata:</span>
<span class="doccomment">///   * The first spec: VMGlobalXXXSpec::side_first()</span>
<span class="doccomment">///   * The following specs: VMGlobalXXXSpec::side_after(FIRST_GLOAL.as_spec())</span>
<span class="doccomment">/// * For *local* side metadata:</span>
<span class="doccomment">///   * The first spec: VMLocalXXXSpec::side_first()</span>
<span class="doccomment">///   * The following specs: VMLocalXXXSpec::side_after(FIRST_LOCAL.as_spec())</span>
<span class="doccomment">///</span>
<span class="doccomment">/// Detailed explanation</span>
<span class="doccomment">///</span>
<span class="doccomment">/// There are two types of side metadata layout in MMTk:</span>
<span class="doccomment">///</span>
<span class="doccomment">/// 1. Contiguous layout: is the layout in which the whole metadata space for a SideMetadataSpec is contiguous.</span>
<span class="doccomment">/// 2. Chunked layout: is the layout in which the whole metadata memory space, that is shared between MMTk policies, is divided into metadata-chunks. Each metadata-chunk stores all of the metadata for all `SideMetadataSpec`s which apply to a source-data chunk.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// In 64-bits targets, both Global and PolicySpecific side metadata are contiguous.</span>
<span class="doccomment">/// Also, in 32-bits targets, the Global side metadata is contiguous.</span>
<span class="doccomment">/// This means if the starting address (variable named `offset`) of the metadata space for a SideMetadataSpec (`SPEC1`) is `BASE1`, the starting address (`offset`) of the next SideMetadataSpec (`SPEC2`) will be `BASE1 + total_metadata_space_size(SPEC1)`, which is located immediately after the end of the whole metadata space of `SPEC1`.</span>
<span class="doccomment">/// Now, if we add a third SideMetadataSpec (`SPEC3`), its starting address (`offset`) will be `BASE2 + total_metadata_space_size(SPEC2)`, which is located immediately after the end of the whole metadata space of `SPEC2`.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// In 32-bits targets, the PolicySpecific side metadata is chunked.</span>
<span class="doccomment">/// This means for each chunk (2^22 Bytes) of data, which, by definition, is managed by exactly one MMTk policy, there is a metadata chunk (2^22 * some_fixed_ratio Bytes) that contains all of its PolicySpecific metadata.</span>
<span class="doccomment">/// This means if a policy has one SideMetadataSpec (`LS1`), the `offset` of that spec will be `0` (= at the start of a metadata chunk).</span>
<span class="doccomment">/// If there is a second SideMetadataSpec (`LS2`) for this specific policy, the `offset` for that spec will be `0 + required_metadata_space_per_chunk(LS1)`,</span>
<span class="doccomment">/// and for a third SideMetadataSpec (`LS3`), the `offset` will be `BASE(LS2) + required_metadata_space_per_chunk(LS2)`.</span>
<span class="doccomment">///</span>
<span class="doccomment">/// For all other policies, the `offset` starts from zero. This is safe because no two policies ever manage one chunk, so there will be no overlap.</span>
<span class="kw">pub</span> <span class="kw">trait</span> <span class="ident">ObjectModel</span><span class="op">&lt;</span><span class="ident">VM</span>: <span class="ident">VMBinding</span><span class="op">&gt;</span> {
    <span class="comment">// Per-object Metadata Spec definitions go here</span>
    <span class="comment">//</span>
    <span class="comment">// Note a number of Global and PolicySpecific side metadata specifications are already reserved by mmtk-core.</span>
    <span class="comment">// Any side metadata offset calculation must consider these to prevent overlaps. A binding should start their</span>
    <span class="comment">// side metadata from GLOBAL_SIDE_METADATA_VM_BASE_ADDRESS or LOCAL_SIDE_METADATA_VM_BASE_ADDRESS.</span>

    <span class="doccomment">/// The metadata specification of the global log bit. 1 bit.</span>
    <span class="doccomment">/// Note that for this bit, 0 represents logged (default), and 1 represents unlogged.</span>
    <span class="doccomment">/// This bit is also referred to as unlogged bit in Java MMTk for this reason.</span>
    <span class="kw">const</span> <span class="ident">GLOBAL_LOG_BIT_SPEC</span>: <span class="ident">VMGlobalLogBitSpec</span>;

    <span class="doccomment">/// The metadata specification for the forwarding pointer, used by copying plans. Word size.</span>
    <span class="kw">const</span> <span class="ident">LOCAL_FORWARDING_POINTER_SPEC</span>: <span class="ident">VMLocalForwardingPointerSpec</span>;
    <span class="doccomment">/// The metadata specification for the forwarding status bits, used by copying plans. 2 bits.</span>
    <span class="kw">const</span> <span class="ident">LOCAL_FORWARDING_BITS_SPEC</span>: <span class="ident">VMLocalForwardingBitsSpec</span>;
    <span class="doccomment">/// The metadata specification for the mark bit, used by most plans that need to mark live objects. 1 bit.</span>
    <span class="kw">const</span> <span class="ident">LOCAL_MARK_BIT_SPEC</span>: <span class="ident">VMLocalMarkBitSpec</span>;
    <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;object_pinning&quot;</span>)]</span>
    <span class="doccomment">/// The metadata specification for the pinning bit, used by most plans that need to pin objects. 1 bit.</span>
    <span class="kw">const</span> <span class="ident">LOCAL_PINNING_BIT_SPEC</span>: <span class="ident">VMLocalPinningBitSpec</span>;
    <span class="doccomment">/// The metadata specification for the mark-and-nursery bits, used by most plans that has large object allocation. 2 bits.</span>
    <span class="kw">const</span> <span class="ident">LOCAL_LOS_MARK_NURSERY_SPEC</span>: <span class="ident">VMLocalLOSMarkNurserySpec</span>;

    <span class="doccomment">/// A function to non-atomically load the specified per-object metadata&#39;s content.</span>
    <span class="doccomment">/// The default implementation assumes the bits defined by the spec are always avilable for MMTk to use. If that is not the case, a binding should override this method, and provide their implementation.</span>
    <span class="doccomment">/// Returns the metadata value.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// # Arguments:</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// * `metadata_spec`: is the header metadata spec that tries to perform the operation.</span>
    <span class="doccomment">/// * `object`: is a reference to the target object.</span>
    <span class="doccomment">/// * `mask`: is an optional mask value for the metadata. This value is used in cases like the forwarding pointer metadata, where some of the bits are reused by other metadata such as the forwarding bits.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// # Safety</span>
    <span class="doccomment">/// This is a non-atomic load, thus not thread-safe.</span>
    <span class="attribute">#[<span class="ident">inline</span>(<span class="ident">always</span>)]</span>
    <span class="kw">unsafe</span> <span class="kw">fn</span> <span class="ident">load_metadata</span><span class="op">&lt;</span><span class="ident">T</span>: <span class="ident">MetadataValue</span><span class="op">&gt;</span>(
        <span class="ident">metadata_spec</span>: <span class="kw-2">&amp;</span><span class="ident">HeaderMetadataSpec</span>,
        <span class="ident">object</span>: <span class="ident">ObjectReference</span>,
        <span class="ident">mask</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>,
    ) -&gt; <span class="ident">T</span> {
        <span class="ident">metadata_spec</span>.<span class="ident">load</span>::<span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>(<span class="ident">object</span>.<span class="ident">to_header</span>::<span class="op">&lt;</span><span class="ident">VM</span><span class="op">&gt;</span>(), <span class="ident">mask</span>)
    }

    <span class="doccomment">/// A function to atomically load the specified per-object metadata&#39;s content.</span>
    <span class="doccomment">/// The default implementation assumes the bits defined by the spec are always avilable for MMTk to use. If that is not the case, a binding should override this method, and provide their implementation.</span>
    <span class="doccomment">/// Returns the metadata value.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// # Arguments:</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// * `metadata_spec`: is the header metadata spec that tries to perform the operation.</span>
    <span class="doccomment">/// * `object`: is a reference to the target object.</span>
    <span class="doccomment">/// * `mask`: is an optional mask value for the metadata. This value is used in cases like the forwarding pointer metadata, where some of the bits are reused by other metadata such as the forwarding bits.</span>
    <span class="doccomment">/// * `atomic_ordering`: is the atomic ordering for the load operation.</span>
    <span class="attribute">#[<span class="ident">inline</span>(<span class="ident">always</span>)]</span>
    <span class="kw">fn</span> <span class="ident">load_metadata_atomic</span><span class="op">&lt;</span><span class="ident">T</span>: <span class="ident">MetadataValue</span><span class="op">&gt;</span>(
        <span class="ident">metadata_spec</span>: <span class="kw-2">&amp;</span><span class="ident">HeaderMetadataSpec</span>,
        <span class="ident">object</span>: <span class="ident">ObjectReference</span>,
        <span class="ident">mask</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>,
        <span class="ident">ordering</span>: <span class="ident">Ordering</span>,
    ) -&gt; <span class="ident">T</span> {
        <span class="ident">metadata_spec</span>.<span class="ident">load_atomic</span>::<span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>(<span class="ident">object</span>.<span class="ident">to_header</span>::<span class="op">&lt;</span><span class="ident">VM</span><span class="op">&gt;</span>(), <span class="ident">mask</span>, <span class="ident">ordering</span>)
    }

    <span class="doccomment">/// A function to non-atomically store a value to the specified per-object metadata.</span>
    <span class="doccomment">/// The default implementation assumes the bits defined by the spec are always avilable for MMTk to use. If that is not the case, a binding should override this method, and provide their implementation.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// # Arguments:</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// * `metadata_spec`: is the header metadata spec that tries to perform the operation.</span>
    <span class="doccomment">/// * `object`: is a reference to the target object.</span>
    <span class="doccomment">/// * `val`: is the new metadata value to be stored.</span>
    <span class="doccomment">/// * `mask`: is an optional mask value for the metadata. This value is used in cases like the forwarding pointer metadata, where some of the bits are reused by other metadata such as the forwarding bits.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// # Safety</span>
    <span class="doccomment">/// This is a non-atomic store, thus not thread-safe.</span>
    <span class="attribute">#[<span class="ident">inline</span>(<span class="ident">always</span>)]</span>
    <span class="kw">unsafe</span> <span class="kw">fn</span> <span class="ident">store_metadata</span><span class="op">&lt;</span><span class="ident">T</span>: <span class="ident">MetadataValue</span><span class="op">&gt;</span>(
        <span class="ident">metadata_spec</span>: <span class="kw-2">&amp;</span><span class="ident">HeaderMetadataSpec</span>,
        <span class="ident">object</span>: <span class="ident">ObjectReference</span>,
        <span class="ident">val</span>: <span class="ident">T</span>,
        <span class="ident">mask</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>,
    ) {
        <span class="ident">metadata_spec</span>.<span class="ident">store</span>::<span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>(<span class="ident">object</span>.<span class="ident">to_header</span>::<span class="op">&lt;</span><span class="ident">VM</span><span class="op">&gt;</span>(), <span class="ident">val</span>, <span class="ident">mask</span>)
    }

    <span class="doccomment">/// A function to atomically store a value to the specified per-object metadata.</span>
    <span class="doccomment">/// The default implementation assumes the bits defined by the spec are always avilable for MMTk to use. If that is not the case, a binding should override this method, and provide their implementation.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// # Arguments:</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// * `metadata_spec`: is the header metadata spec that tries to perform the operation.</span>
    <span class="doccomment">/// * `object`: is a reference to the target object.</span>
    <span class="doccomment">/// * `val`: is the new metadata value to be stored.</span>
    <span class="doccomment">/// * `mask`: is an optional mask value for the metadata. This value is used in cases like the forwarding pointer metadata, where some of the bits are reused by other metadata such as the forwarding bits.</span>
    <span class="doccomment">/// * `atomic_ordering`: is the optional atomic ordering for the store operation.</span>
    <span class="attribute">#[<span class="ident">inline</span>(<span class="ident">always</span>)]</span>
    <span class="kw">fn</span> <span class="ident">store_metadata_atomic</span><span class="op">&lt;</span><span class="ident">T</span>: <span class="ident">MetadataValue</span><span class="op">&gt;</span>(
        <span class="ident">metadata_spec</span>: <span class="kw-2">&amp;</span><span class="ident">HeaderMetadataSpec</span>,
        <span class="ident">object</span>: <span class="ident">ObjectReference</span>,
        <span class="ident">val</span>: <span class="ident">T</span>,
        <span class="ident">mask</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>,
        <span class="ident">ordering</span>: <span class="ident">Ordering</span>,
    ) {
        <span class="ident">metadata_spec</span>.<span class="ident">store_atomic</span>::<span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>(<span class="ident">object</span>.<span class="ident">to_header</span>::<span class="op">&lt;</span><span class="ident">VM</span><span class="op">&gt;</span>(), <span class="ident">val</span>, <span class="ident">mask</span>, <span class="ident">ordering</span>)
    }

    <span class="doccomment">/// A function to atomically compare-and-exchange the specified per-object metadata&#39;s content.</span>
    <span class="doccomment">/// The default implementation assumes the bits defined by the spec are always avilable for MMTk to use. If that is not the case, a binding should override this method, and provide their implementation.</span>
    <span class="doccomment">/// Returns `true` if the operation is successful, and `false` otherwise.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// # Arguments:</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// * `metadata_spec`: is the header metadata spec that tries to perform the operation.</span>
    <span class="doccomment">/// * `object`: is a reference to the target object.</span>
    <span class="doccomment">/// * `old_val`: is the expected current value of the metadata.</span>
    <span class="doccomment">/// * `new_val`: is the new metadata value to be stored if the compare-and-exchange operation is successful.</span>
    <span class="doccomment">/// * `mask`: is an optional mask value for the metadata. This value is used in cases like the forwarding pointer metadata, where some of the bits are reused by other metadata such as the forwarding bits.</span>
    <span class="doccomment">/// * `success_order`: is the atomic ordering used if the operation is successful.</span>
    <span class="doccomment">/// * `failure_order`: is the atomic ordering used if the operation fails.</span>
    <span class="attribute">#[<span class="ident">inline</span>(<span class="ident">always</span>)]</span>
    <span class="kw">fn</span> <span class="ident">compare_exchange_metadata</span><span class="op">&lt;</span><span class="ident">T</span>: <span class="ident">MetadataValue</span><span class="op">&gt;</span>(
        <span class="ident">metadata_spec</span>: <span class="kw-2">&amp;</span><span class="ident">HeaderMetadataSpec</span>,
        <span class="ident">object</span>: <span class="ident">ObjectReference</span>,
        <span class="ident">old_val</span>: <span class="ident">T</span>,
        <span class="ident">new_val</span>: <span class="ident">T</span>,
        <span class="ident">mask</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>,
        <span class="ident">success_order</span>: <span class="ident">Ordering</span>,
        <span class="ident">failure_order</span>: <span class="ident">Ordering</span>,
    ) -&gt; <span class="ident">std::result::Result</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">T</span><span class="op">&gt;</span> {
        <span class="ident">metadata_spec</span>.<span class="ident">compare_exchange</span>::<span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>(
            <span class="ident">object</span>.<span class="ident">to_header</span>::<span class="op">&lt;</span><span class="ident">VM</span><span class="op">&gt;</span>(),
            <span class="ident">old_val</span>,
            <span class="ident">new_val</span>,
            <span class="ident">mask</span>,
            <span class="ident">success_order</span>,
            <span class="ident">failure_order</span>,
        )
    }

    <span class="doccomment">/// A function to atomically perform an add operation on the specified per-object metadata&#39;s content.</span>
    <span class="doccomment">/// The default implementation assumes the bits defined by the spec are always avilable for MMTk to use. If that is not the case, a binding should override this method, and provide their implementation.</span>
    <span class="doccomment">/// This is a wrapping add.</span>
    <span class="doccomment">/// # Returns the old metadata value.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// # Arguments:</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// * `metadata_spec`: is the header metadata spec that tries to perform the operation.</span>
    <span class="doccomment">/// * `object`: is a reference to the target object.</span>
    <span class="doccomment">/// * `val`: is the value to be added to the current value of the metadata.</span>
    <span class="doccomment">/// * `order`: is the atomic ordering of the fetch-and-add operation.</span>
    <span class="attribute">#[<span class="ident">inline</span>(<span class="ident">always</span>)]</span>
    <span class="kw">fn</span> <span class="ident">fetch_add_metadata</span><span class="op">&lt;</span><span class="ident">T</span>: <span class="ident">MetadataValue</span><span class="op">&gt;</span>(
        <span class="ident">metadata_spec</span>: <span class="kw-2">&amp;</span><span class="ident">HeaderMetadataSpec</span>,
        <span class="ident">object</span>: <span class="ident">ObjectReference</span>,
        <span class="ident">val</span>: <span class="ident">T</span>,
        <span class="ident">order</span>: <span class="ident">Ordering</span>,
    ) -&gt; <span class="ident">T</span> {
        <span class="ident">metadata_spec</span>.<span class="ident">fetch_add</span>::<span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>(<span class="ident">object</span>.<span class="ident">to_header</span>::<span class="op">&lt;</span><span class="ident">VM</span><span class="op">&gt;</span>(), <span class="ident">val</span>, <span class="ident">order</span>)
    }

    <span class="doccomment">/// A function to atomically perform a subtract operation on the specified per-object metadata&#39;s content.</span>
    <span class="doccomment">/// The default implementation assumes the bits defined by the spec are always avilable for MMTk to use. If that is not the case, a binding should override this method, and provide their implementation.</span>
    <span class="doccomment">/// This is a wrapping sub.</span>
    <span class="doccomment">/// Returns the old metadata value.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// # Arguments:</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// * `metadata_spec`: is the header metadata spec that tries to perform the operation.</span>
    <span class="doccomment">/// * `object`: is a reference to the target object.</span>
    <span class="doccomment">/// * `val`: is the value to be subtracted from the current value of the metadata.</span>
    <span class="doccomment">/// * `order`: is the atomic ordering of the fetch-and-add operation.</span>
    <span class="attribute">#[<span class="ident">inline</span>(<span class="ident">always</span>)]</span>
    <span class="kw">fn</span> <span class="ident">fetch_sub_metadata</span><span class="op">&lt;</span><span class="ident">T</span>: <span class="ident">MetadataValue</span><span class="op">&gt;</span>(
        <span class="ident">metadata_spec</span>: <span class="kw-2">&amp;</span><span class="ident">HeaderMetadataSpec</span>,
        <span class="ident">object</span>: <span class="ident">ObjectReference</span>,
        <span class="ident">val</span>: <span class="ident">T</span>,
        <span class="ident">order</span>: <span class="ident">Ordering</span>,
    ) -&gt; <span class="ident">T</span> {
        <span class="ident">metadata_spec</span>.<span class="ident">fetch_sub</span>::<span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>(<span class="ident">object</span>.<span class="ident">to_header</span>::<span class="op">&lt;</span><span class="ident">VM</span><span class="op">&gt;</span>(), <span class="ident">val</span>, <span class="ident">order</span>)
    }

    <span class="doccomment">/// A function to atomically perform a bit-and operation on the specified per-object metadata&#39;s content.</span>
    <span class="doccomment">/// The default implementation assumes the bits defined by the spec are always avilable for MMTk to use. If that is not the case, a binding should override this method, and provide their implementation.</span>
    <span class="doccomment">/// Returns the old metadata value.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// # Arguments:</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// * `metadata_spec`: is the header metadata spec that tries to perform the operation.</span>
    <span class="doccomment">/// * `object`: is a reference to the target object.</span>
    <span class="doccomment">/// * `val`: is the value to bit-and with the current value of the metadata.</span>
    <span class="doccomment">/// * `order`: is the atomic ordering of the fetch-and-add operation.</span>
    <span class="attribute">#[<span class="ident">inline</span>(<span class="ident">always</span>)]</span>
    <span class="kw">fn</span> <span class="ident">fetch_and_metadata</span><span class="op">&lt;</span><span class="ident">T</span>: <span class="ident">MetadataValue</span><span class="op">&gt;</span>(
        <span class="ident">metadata_spec</span>: <span class="kw-2">&amp;</span><span class="ident">HeaderMetadataSpec</span>,
        <span class="ident">object</span>: <span class="ident">ObjectReference</span>,
        <span class="ident">val</span>: <span class="ident">T</span>,
        <span class="ident">order</span>: <span class="ident">Ordering</span>,
    ) -&gt; <span class="ident">T</span> {
        <span class="ident">metadata_spec</span>.<span class="ident">fetch_and</span>::<span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>(<span class="ident">object</span>.<span class="ident">to_header</span>::<span class="op">&lt;</span><span class="ident">VM</span><span class="op">&gt;</span>(), <span class="ident">val</span>, <span class="ident">order</span>)
    }

    <span class="doccomment">/// A function to atomically perform a bit-or operation on the specified per-object metadata&#39;s content.</span>
    <span class="doccomment">/// The default implementation assumes the bits defined by the spec are always avilable for MMTk to use. If that is not the case, a binding should override this method, and provide their implementation.</span>
    <span class="doccomment">/// Returns the old metadata value.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// # Arguments:</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// * `metadata_spec`: is the header metadata spec that tries to perform the operation.</span>
    <span class="doccomment">/// * `object`: is a reference to the target object.</span>
    <span class="doccomment">/// * `val`: is the value to bit-or with the current value of the metadata.</span>
    <span class="doccomment">/// * `order`: is the atomic ordering of the fetch-and-add operation.</span>
    <span class="attribute">#[<span class="ident">inline</span>(<span class="ident">always</span>)]</span>
    <span class="kw">fn</span> <span class="ident">fetch_or_metadata</span><span class="op">&lt;</span><span class="ident">T</span>: <span class="ident">MetadataValue</span><span class="op">&gt;</span>(
        <span class="ident">metadata_spec</span>: <span class="kw-2">&amp;</span><span class="ident">HeaderMetadataSpec</span>,
        <span class="ident">object</span>: <span class="ident">ObjectReference</span>,
        <span class="ident">val</span>: <span class="ident">T</span>,
        <span class="ident">order</span>: <span class="ident">Ordering</span>,
    ) -&gt; <span class="ident">T</span> {
        <span class="ident">metadata_spec</span>.<span class="ident">fetch_or</span>::<span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>(<span class="ident">object</span>.<span class="ident">to_header</span>::<span class="op">&lt;</span><span class="ident">VM</span><span class="op">&gt;</span>(), <span class="ident">val</span>, <span class="ident">order</span>)
    }

    <span class="doccomment">/// A function to atomically perform an update operation on the specified per-object metadata&#39;s content.</span>
    <span class="doccomment">/// The default implementation assumes the bits defined by the spec are always avilable for MMTk to use. If that is not the case, a binding should override this method, and provide their implementation.</span>
    <span class="doccomment">/// The semantics of this method are the same as the `fetch_update()` on Rust atomic types.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// # Arguments:</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// * `metadata_spec`: is the header metadata spec that tries to perform the operation.</span>
    <span class="doccomment">/// * `object`: is a reference to the target object.</span>
    <span class="doccomment">/// * `val`: is the value to bit-and with the current value of the metadata.</span>
    <span class="doccomment">/// * `order`: is the atomic ordering of the fetch-and-add operation.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// # Returns the old metadata value.</span>
    <span class="attribute">#[<span class="ident">inline</span>(<span class="ident">always</span>)]</span>
    <span class="kw">fn</span> <span class="ident">fetch_update_metadata</span><span class="op">&lt;</span><span class="ident">T</span>: <span class="ident">MetadataValue</span>, <span class="ident">F</span>: <span class="ident">FnMut</span>(<span class="ident">T</span>) -&gt; <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> <span class="op">+</span> <span class="ident">Copy</span><span class="op">&gt;</span>(
        <span class="ident">metadata_spec</span>: <span class="kw-2">&amp;</span><span class="ident">HeaderMetadataSpec</span>,
        <span class="ident">object</span>: <span class="ident">ObjectReference</span>,
        <span class="ident">set_order</span>: <span class="ident">Ordering</span>,
        <span class="ident">fetch_order</span>: <span class="ident">Ordering</span>,
        <span class="ident">f</span>: <span class="ident">F</span>,
    ) -&gt; <span class="ident">std::result::Result</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">T</span><span class="op">&gt;</span> {
        <span class="ident">metadata_spec</span>.<span class="ident">fetch_update</span>::<span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">F</span><span class="op">&gt;</span>(<span class="ident">object</span>.<span class="ident">to_header</span>::<span class="op">&lt;</span><span class="ident">VM</span><span class="op">&gt;</span>(), <span class="ident">set_order</span>, <span class="ident">fetch_order</span>, <span class="ident">f</span>)
    }

    <span class="doccomment">/// Copy an object and return the address of the new object. Usually in the implementation of this method,</span>
    <span class="doccomment">/// `alloc_copy()` and `post_copy()` from [`GCWorkerCopyContext`](util/copy/struct.GCWorkerCopyContext.html)</span>
    <span class="doccomment">/// are used for copying.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// Arguments:</span>
    <span class="doccomment">/// * `from`: The address of the object to be copied.</span>
    <span class="doccomment">/// * `semantics`: The copy semantic to use.</span>
    <span class="doccomment">/// * `copy_context`: The `GCWorkerCopyContext` for the GC thread.</span>
    <span class="kw">fn</span> <span class="ident">copy</span>(
        <span class="ident">from</span>: <span class="ident">ObjectReference</span>,
        <span class="ident">semantics</span>: <span class="ident">CopySemantics</span>,
        <span class="ident">copy_context</span>: <span class="kw-2">&amp;mut</span> <span class="ident">GCWorkerCopyContext</span><span class="op">&lt;</span><span class="ident">VM</span><span class="op">&gt;</span>,
    ) -&gt; <span class="ident">ObjectReference</span>;

    <span class="doccomment">/// Copy an object. This is required</span>
    <span class="doccomment">/// for delayed-copy collectors such as compacting collectors. During the</span>
    <span class="doccomment">/// collection, MMTk reserves a region in the heap for an object as per</span>
    <span class="doccomment">/// requirements found from `ObjectModel` and then asks `ObjectModel` to</span>
    <span class="doccomment">/// determine what the object&#39;s reference will be post-copy. Return the address</span>
    <span class="doccomment">/// past the end of the copied object.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// Arguments:</span>
    <span class="doccomment">/// * `from`: The address of the object to be copied.</span>
    <span class="doccomment">/// * `to`: The target location.</span>
    <span class="doccomment">/// * `region: The start of the region that was reserved for this object.</span>
    <span class="kw">fn</span> <span class="ident">copy_to</span>(<span class="ident">from</span>: <span class="ident">ObjectReference</span>, <span class="ident">to</span>: <span class="ident">ObjectReference</span>, <span class="ident">region</span>: <span class="ident">Address</span>) -&gt; <span class="ident">Address</span>;

    <span class="doccomment">/// Return the reference that an object will be referred to after it is copied</span>
    <span class="doccomment">/// to the specified region. Used in delayed-copy collectors such as compacting</span>
    <span class="doccomment">/// collectors.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// Arguments:</span>
    <span class="doccomment">/// * `from`: The object to be copied.</span>
    <span class="doccomment">/// * `to`: The region to be copied to.</span>
    <span class="kw">fn</span> <span class="ident">get_reference_when_copied_to</span>(<span class="ident">from</span>: <span class="ident">ObjectReference</span>, <span class="ident">to</span>: <span class="ident">Address</span>) -&gt; <span class="ident">ObjectReference</span>;

    <span class="doccomment">/// Return the size used by an object.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// Arguments:</span>
    <span class="doccomment">/// * `object`: The object to be queried.</span>
    <span class="kw">fn</span> <span class="ident">get_current_size</span>(<span class="ident">object</span>: <span class="ident">ObjectReference</span>) -&gt; <span class="ident">usize</span>;

    <span class="doccomment">/// Return the size when an object is copied.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// Arguments:</span>
    <span class="doccomment">/// * `object`: The object to be queried.</span>
    <span class="kw">fn</span> <span class="ident">get_size_when_copied</span>(<span class="ident">object</span>: <span class="ident">ObjectReference</span>) -&gt; <span class="ident">usize</span>;

    <span class="doccomment">/// Return the alignment when an object is copied.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// Arguments:</span>
    <span class="doccomment">/// * `object`: The object to be queried.</span>
    <span class="kw">fn</span> <span class="ident">get_align_when_copied</span>(<span class="ident">object</span>: <span class="ident">ObjectReference</span>) -&gt; <span class="ident">usize</span>;

    <span class="doccomment">/// Return the alignment offset when an object is copied.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// Arguments:</span>
    <span class="doccomment">/// * `object`: The object to be queried.</span>
    <span class="kw">fn</span> <span class="ident">get_align_offset_when_copied</span>(<span class="ident">object</span>: <span class="ident">ObjectReference</span>) -&gt; <span class="ident">isize</span>;

    <span class="doccomment">/// Get the type descriptor for an object.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// FIXME: Do we need this? If so, determine lifetime, return byte[]</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// Arguments:</span>
    <span class="doccomment">/// * `reference`: The object to be queried.</span>
    <span class="kw">fn</span> <span class="ident">get_type_descriptor</span>(<span class="ident">reference</span>: <span class="ident">ObjectReference</span>) -&gt; <span class="kw-2">&amp;</span><span class="lifetime">&#39;static</span> [<span class="ident">i8</span>];

    <span class="doccomment">/// This is the worst case expansion that can occur due to object size increasing while</span>
    <span class="doccomment">/// copying. This constant is used to calculate whether a nursery has grown larger than the</span>
    <span class="doccomment">/// mature space for generational plans.</span>
    <span class="kw">const</span> <span class="ident">VM_WORST_CASE_COPY_EXPANSION</span>: <span class="ident">f64</span> <span class="op">=</span> <span class="number">1.5</span>;

    <span class="doccomment">/// If this is true, the binding guarantees that an object reference&#39;s raw address is always equal to the return value of the `ref_to_address` method</span>
    <span class="doccomment">/// and the return value of the `ref_to_object_start` method. This is a very strong guarantee, but it is also helpful for MMTk to</span>
    <span class="doccomment">/// make some assumptions and optimize for this case.</span>
    <span class="doccomment">/// If a binding sets this to true, and the related methods return inconsistent results, this is an undefined behavior. MMTk may panic</span>
    <span class="doccomment">/// if any assertion catches this error, but may also fail silently.</span>
    <span class="kw">const</span> <span class="ident">UNIFIED_OBJECT_REFERENCE_ADDRESS</span>: <span class="ident">bool</span> <span class="op">=</span> <span class="bool-val">false</span>;

    <span class="doccomment">/// For our allocation result (object_start), the binding may have an offset between the allocation result</span>
    <span class="doccomment">/// and the raw address of their object reference, i.e. object ref&#39;s raw address = object_start + offset.</span>
    <span class="doccomment">/// The offset could be zero. The offset is not necessary to be</span>
    <span class="doccomment">/// constant for all the objects. This constant defines the smallest possible offset.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// This is used as an indication for MMTk to predict where object references may point to in some algorithms.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// We should have the invariant:</span>
    <span class="doccomment">/// * object ref &gt;= object_start + OBJECT_REF_OFFSET_LOWER_BOUND</span>
    <span class="kw">const</span> <span class="ident">OBJECT_REF_OFFSET_LOWER_BOUND</span>: <span class="ident">isize</span>;

    <span class="doccomment">/// Return the lowest address of the storage associated with an object. This should be</span>
    <span class="doccomment">/// the address that a binding gets by an allocation call ([`crate::memory_manager::alloc`]).</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// Arguments:</span>
    <span class="doccomment">/// * `object`: The object to be queried. It should not be null.</span>
    <span class="kw">fn</span> <span class="ident">ref_to_object_start</span>(<span class="ident">object</span>: <span class="ident">ObjectReference</span>) -&gt; <span class="ident">Address</span>;

    <span class="doccomment">/// Return the header base address from an object reference. Any object header metadata</span>
    <span class="doccomment">/// in the [`crate::vm::ObjectModel`] declares a piece of header metadata with an offset</span>
    <span class="doccomment">/// from this address. If a binding does not use any header metadata for MMTk, this method</span>
    <span class="doccomment">/// will not be called, and the binding can simply use `unreachable!()` for the method.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// Arguments:</span>
    <span class="doccomment">/// * `object`: The object to be queried. It should not be null.</span>
    <span class="kw">fn</span> <span class="ident">ref_to_header</span>(<span class="ident">object</span>: <span class="ident">ObjectReference</span>) -&gt; <span class="ident">Address</span>;

    <span class="doccomment">/// Return an address guaranteed to be inside the storage associated</span>
    <span class="doccomment">/// with an object. The returned address needs to be deterministic</span>
    <span class="doccomment">/// for an given object. For a given object, the returned address</span>
    <span class="doccomment">/// should be a constant offset from the object reference address.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// Note that MMTk may forge an arbitrary address</span>
    <span class="doccomment">/// directly into a potential object reference, and call this method on the &#39;object reference&#39;.</span>
    <span class="doccomment">/// In that case, the argument `object` may not be a valid object reference,</span>
    <span class="doccomment">/// and the implementation of this method should not use any object metadata.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// MMTk uses this method more frequently than [`crate::vm::ObjectModel::ref_to_object_start`].</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// Arguments:</span>
    <span class="doccomment">/// * `object`: The object to be queried. It should not be null.</span>
    <span class="kw">fn</span> <span class="ident">ref_to_address</span>(<span class="ident">object</span>: <span class="ident">ObjectReference</span>) -&gt; <span class="ident">Address</span>;

    <span class="doccomment">/// Return an object for a given address returned by `ref_to_address()`.</span>
    <span class="doccomment">/// This does exactly the opposite of `ref_to_address()`. The argument `addr` has</span>
    <span class="doccomment">/// to be an address that is previously returned from `ref_to_address()`. Invoking this method</span>
    <span class="doccomment">/// with an unexpected address is undefined behavior.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// Arguments:</span>
    <span class="doccomment">/// * `addr`: An address that is returned from `ref_to_address()`</span>
    <span class="kw">fn</span> <span class="ident">address_to_ref</span>(<span class="ident">addr</span>: <span class="ident">Address</span>) -&gt; <span class="ident">ObjectReference</span>;

    <span class="doccomment">/// Dump debugging information for an object.</span>
    <span class="doccomment">///</span>
    <span class="doccomment">/// Arguments:</span>
    <span class="doccomment">/// * `object`: The object to be dumped.</span>
    <span class="kw">fn</span> <span class="ident">dump_object</span>(<span class="ident">object</span>: <span class="ident">ObjectReference</span>);
}

<span class="kw">pub</span> <span class="kw">mod</span> <span class="ident">specs</span> {
    <span class="kw">use</span> <span class="ident"><span class="kw">crate</span>::util::constants::LOG_BITS_IN_WORD</span>;
    <span class="kw">use</span> <span class="ident"><span class="kw">crate</span>::util::constants::LOG_BYTES_IN_PAGE</span>;
    <span class="kw">use</span> <span class="ident"><span class="kw">crate</span>::util::constants::LOG_MIN_OBJECT_SIZE</span>;
    <span class="kw">use</span> <span class="ident"><span class="kw">crate</span>::util::metadata::side_metadata</span>::<span class="kw-2">*</span>;
    <span class="kw">use</span> <span class="ident"><span class="kw">crate</span>::util::metadata</span>::{
        <span class="ident">header_metadata::HeaderMetadataSpec</span>,
        <span class="ident">side_metadata</span>::{<span class="ident">SideMetadataOffset</span>, <span class="ident">SideMetadataSpec</span>},
        <span class="ident">MetadataSpec</span>,
    };

    <span class="comment">// This macro is invoked in define_vm_metadata_global_spec or define_vm_metadata_local_spec.</span>
    <span class="comment">// Use those two to define a new VM metadata spec.</span>
    <span class="macro">macro_rules!</span> <span class="ident">define_vm_metadata_spec</span> {
        (<span class="macro-nonterminal">$</span><span class="macro-nonterminal">spec_name</span>: <span class="ident">ident</span>, <span class="macro-nonterminal">$</span><span class="macro-nonterminal">is_global</span>: <span class="ident">expr</span>, <span class="macro-nonterminal">$</span><span class="macro-nonterminal">log_num_bits</span>: <span class="ident">expr</span>, <span class="macro-nonterminal">$</span><span class="macro-nonterminal">side_min_obj_size</span>: <span class="ident">expr</span>) =&gt; {
            <span class="kw">pub</span> <span class="kw">struct</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">spec_name</span>(<span class="ident">MetadataSpec</span>);
            <span class="kw">impl</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">spec_name</span> {
                <span class="kw">pub</span> <span class="kw">const</span> <span class="ident">LOG_NUM_BITS</span>: <span class="ident">usize</span> <span class="op">=</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">log_num_bits</span>;
                <span class="kw">pub</span> <span class="kw">const</span> <span class="ident">IS_GLOBAL</span>: <span class="ident">bool</span> <span class="op">=</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">is_global</span>;
                <span class="kw">pub</span> <span class="kw">const</span> <span class="kw">fn</span> <span class="ident">in_header</span>(<span class="ident">bit_offset</span>: <span class="ident">isize</span>) -&gt; <span class="self">Self</span> {
                    <span class="self">Self</span>(<span class="ident">MetadataSpec::InHeader</span>(<span class="ident">HeaderMetadataSpec</span> {
                        <span class="ident">bit_offset</span>,
                        <span class="ident">num_of_bits</span>: <span class="number">1</span> <span class="op">&lt;</span><span class="op">&lt;</span> <span class="ident"><span class="self">Self</span>::LOG_NUM_BITS</span>,
                    }))
                }
                <span class="kw">pub</span> <span class="kw">const</span> <span class="kw">fn</span> <span class="ident">side_first</span>() -&gt; <span class="self">Self</span> {
                    <span class="kw">if</span> <span class="ident"><span class="self">Self</span>::IS_GLOBAL</span> {
                        <span class="self">Self</span>(<span class="ident">MetadataSpec::OnSide</span>(<span class="ident">SideMetadataSpec</span> {
                            <span class="ident">name</span>: <span class="macro">stringify!</span>(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">spec_name</span>),
                            <span class="ident">is_global</span>: <span class="ident"><span class="self">Self</span>::IS_GLOBAL</span>,
                            <span class="ident">offset</span>: <span class="ident">GLOBAL_SIDE_METADATA_VM_BASE_OFFSET</span>,
                            <span class="ident">log_num_of_bits</span>: <span class="ident"><span class="self">Self</span>::LOG_NUM_BITS</span>,
                            <span class="ident">log_bytes_in_region</span>: <span class="macro-nonterminal">$</span><span class="macro-nonterminal">side_min_obj_size</span> <span class="kw">as</span> <span class="ident">usize</span>,
                        }))
                    } <span class="kw">else</span> {
                        <span class="self">Self</span>(<span class="ident">MetadataSpec::OnSide</span>(<span class="ident">SideMetadataSpec</span> {
                            <span class="ident">name</span>: <span class="macro">stringify!</span>(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">spec_name</span>),
                            <span class="ident">is_global</span>: <span class="ident"><span class="self">Self</span>::IS_GLOBAL</span>,
                            <span class="ident">offset</span>: <span class="ident">LOCAL_SIDE_METADATA_VM_BASE_OFFSET</span>,
                            <span class="ident">log_num_of_bits</span>: <span class="ident"><span class="self">Self</span>::LOG_NUM_BITS</span>,
                            <span class="ident">log_bytes_in_region</span>: <span class="macro-nonterminal">$</span><span class="macro-nonterminal">side_min_obj_size</span> <span class="kw">as</span> <span class="ident">usize</span>,
                        }))
                    }
                }
                <span class="kw">pub</span> <span class="kw">const</span> <span class="kw">fn</span> <span class="ident">side_after</span>(<span class="ident">spec</span>: <span class="kw-2">&amp;</span><span class="ident">MetadataSpec</span>) -&gt; <span class="self">Self</span> {
                    <span class="macro">debug_assert!</span>(<span class="ident">spec</span>.<span class="ident">is_on_side</span>());
                    <span class="kw">let</span> <span class="ident">side_spec</span> <span class="op">=</span> <span class="ident">spec</span>.<span class="ident">extract_side_spec</span>();
                    <span class="macro">debug_assert!</span>(<span class="ident">side_spec</span>.<span class="ident">is_global</span> <span class="op">==</span> <span class="ident"><span class="self">Self</span>::IS_GLOBAL</span>);
                    <span class="self">Self</span>(<span class="ident">MetadataSpec::OnSide</span>(<span class="ident">SideMetadataSpec</span> {
                        <span class="ident">name</span>: <span class="macro">stringify!</span>(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">spec_name</span>),
                        <span class="ident">is_global</span>: <span class="ident"><span class="self">Self</span>::IS_GLOBAL</span>,
                        <span class="ident">offset</span>: <span class="ident">SideMetadataOffset::layout_after</span>(<span class="ident">side_spec</span>),
                        <span class="ident">log_num_of_bits</span>: <span class="ident"><span class="self">Self</span>::LOG_NUM_BITS</span>,
                        <span class="ident">log_bytes_in_region</span>: <span class="macro-nonterminal">$</span><span class="macro-nonterminal">side_min_obj_size</span> <span class="kw">as</span> <span class="ident">usize</span>,
                    }))
                }
                <span class="attribute">#[<span class="ident">inline</span>(<span class="ident">always</span>)]</span>
                <span class="kw">pub</span> <span class="kw">const</span> <span class="kw">fn</span> <span class="ident">as_spec</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="kw-2">&amp;</span><span class="ident">MetadataSpec</span> {
                    <span class="kw-2">&amp;</span><span class="self">self</span>.<span class="number">0</span>
                }
                <span class="kw">pub</span> <span class="kw">const</span> <span class="kw">fn</span> <span class="ident">num_bits</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident">usize</span> {
                    <span class="number">1</span> <span class="op">&lt;</span><span class="op">&lt;</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">log_num_bits</span>
                }
            }
            <span class="kw">impl</span> <span class="ident">std::ops::Deref</span> <span class="kw">for</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">spec_name</span> {
                <span class="kw">type</span> <span class="ident">Target</span> <span class="op">=</span> <span class="ident">MetadataSpec</span>;
                <span class="attribute">#[<span class="ident">inline</span>(<span class="ident">always</span>)]</span>
                <span class="kw">fn</span> <span class="ident">deref</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="kw-2">&amp;</span><span class="ident"><span class="self">Self</span>::Target</span> {
                    <span class="self">self</span>.<span class="ident">as_spec</span>()
                }
            }
        };
    }

    <span class="comment">// Log bit: 1 bit per object, global</span>
    <span class="macro">define_vm_metadata_spec!</span>(<span class="ident">VMGlobalLogBitSpec</span>, <span class="bool-val">true</span>, <span class="number">0</span>, <span class="ident">LOG_MIN_OBJECT_SIZE</span>);
    <span class="comment">// Forwarding pointer: word size per object, local</span>
    <span class="macro">define_vm_metadata_spec!</span>(
        <span class="ident">VMLocalForwardingPointerSpec</span>,
        <span class="bool-val">false</span>,
        <span class="ident">LOG_BITS_IN_WORD</span>,
        <span class="ident">LOG_MIN_OBJECT_SIZE</span>
    );
    <span class="comment">// Forwarding bits: 2 bits per object, local</span>
    <span class="macro">define_vm_metadata_spec!</span>(<span class="ident">VMLocalForwardingBitsSpec</span>, <span class="bool-val">false</span>, <span class="number">1</span>, <span class="ident">LOG_MIN_OBJECT_SIZE</span>);
    <span class="comment">// Mark bit: 1 bit per object, local</span>
    <span class="macro">define_vm_metadata_spec!</span>(<span class="ident">VMLocalMarkBitSpec</span>, <span class="bool-val">false</span>, <span class="number">0</span>, <span class="ident">LOG_MIN_OBJECT_SIZE</span>);
    <span class="comment">// Pinning bit: 1 bit per object, local</span>
    <span class="macro">define_vm_metadata_spec!</span>(<span class="ident">VMLocalPinningBitSpec</span>, <span class="bool-val">false</span>, <span class="number">0</span>, <span class="ident">LOG_MIN_OBJECT_SIZE</span>);
    <span class="comment">// Mark&amp;nursery bits for LOS: 2 bit per page, local</span>
    <span class="macro">define_vm_metadata_spec!</span>(<span class="ident">VMLocalLOSMarkNurserySpec</span>, <span class="bool-val">false</span>, <span class="number">1</span>, <span class="ident">LOG_BYTES_IN_PAGE</span>);
}
</code></pre></div>
</section><section id="search" class="content hidden"></section></div></main><div id="rustdoc-vars" data-root-path="../../../" data-current-crate="mmtk" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.59.0 (9d1b2106e 2022-02-23)" ></div>
</body></html>