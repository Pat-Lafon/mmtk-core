<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="VM-to-MMTk interface: safe Rust APIs."><meta name="keywords" content="rust, rustlang, rust-lang, memory_manager"><title>mmtk::memory_manager - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../ayu.css" disabled><link rel="stylesheet" type="text/css" href="../../dark.css" disabled><link rel="stylesheet" type="text/css" href="../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../storage.js"></script><script src="../../crates.js"></script><script defer src="../../main.js"></script>
    <noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../favicon.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../../mmtk/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"></h2>
    </nav>
    <nav class="sidebar"><a class="sidebar-logo" href="../../mmtk/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"><a href="#">Module memory_manager</a></h2><div class="sidebar-elems"><div class="block items"><ul><li><a href="#functions">Functions</a></li></ul></div><div id="sidebar-vars" data-name="memory_manager" data-ty="mod" data-relpath="./"></div><script defer src="./sidebar-items.js"></script></div></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../../mmtk/index.html"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></a><nav class="sub"><div class="theme-picker hidden"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="22" height="22" alt="Pick another theme!" src="../../brush.svg"></button><div id="theme-choices" role="menu"></div></div><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../wheel.svg"></a></div></form></nav></div><section id="main-content" class="content"><div class="main-heading">
    <h1 class="fqn"><span class="in-band">Module <a href="../index.html">mmtk</a>::<wbr><a class="mod" href="#">memory_manager</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span></h1><span class="out-of-band"><a class="srclink" href="../../src/mmtk/memory_manager.rs.html#1-492">source</a> · <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>VM-to-MMTk interface: safe Rust APIs.</p>
<p>This module provides a safe Rust API for mmtk-core.
We expect the VM binding to inherit and extend this API by:</p>
<ol>
<li>adding their VM-specific functions</li>
<li>exposing the functions to native if necessary. And the VM binding needs to manage the unsafety
for exposing this safe API to FFI.</li>
</ol>
<p>For example, for mutators, this API provides a <code>Box&lt;Mutator&gt;</code>, and requires a <code>&amp;mut Mutator</code> for allocation.
A VM binding can borrow a mutable reference directly from <code>Box&lt;Mutator&gt;</code>, and call <code>alloc()</code>. Alternatively,
it can turn the <code>Box</code> pointer to a native pointer (<code>*mut Mutator</code>), and forge a mut reference from the native
pointer. Either way, the VM binding code needs to guarantee the safety.</p>
</div></details><h2 id="functions" class="small-section-header"><a href="#functions">Functions</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.add_finalizer.html" title="mmtk::memory_manager::add_finalizer fn">add_finalizer</a></div><div class="item-right docblock-short"><p>Register a finalizable object. MMTk will retain the liveness of
the object even if it is not reachable from the program.
Note that finalization upon exit is not supported.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.add_phantom_candidate.html" title="mmtk::memory_manager::add_phantom_candidate fn">add_phantom_candidate</a></div><div class="item-right docblock-short"><p>Add a reference to the list of phantom references.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.add_soft_candidate.html" title="mmtk::memory_manager::add_soft_candidate fn">add_soft_candidate</a></div><div class="item-right docblock-short"><p>Add a reference to the list of soft references.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.add_weak_candidate.html" title="mmtk::memory_manager::add_weak_candidate fn">add_weak_candidate</a></div><div class="item-right docblock-short"><p>Add a reference to the list of weak references.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.add_work_packet.html" title="mmtk::memory_manager::add_work_packet fn">add_work_packet</a></div><div class="item-right docblock-short"><p>Add a work packet to the given work bucket. Note that this simply adds the work packet to the given
work bucket, and the scheduler will decide when to execute the work packet.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.add_work_packets.html" title="mmtk::memory_manager::add_work_packets fn">add_work_packets</a></div><div class="item-right docblock-short"><p>Bulk add a number of work packets to the given work bucket. Note that this simply adds the work packets
to the given work bucket, and the scheduler will decide when to execute the work packets.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.alloc.html" title="mmtk::memory_manager::alloc fn">alloc</a></div><div class="item-right docblock-short"><p>Allocate memory for an object. For performance reasons, a VM should
implement the allocation fast-path on their side rather than just calling this function.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.bind_mutator.html" title="mmtk::memory_manager::bind_mutator fn">bind_mutator</a></div><div class="item-right docblock-short"><p>Request MMTk to create a mutator for the given thread. For performance reasons, A VM should
store the returned mutator in a thread local storage that can be accessed efficiently.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.destroy_mutator.html" title="mmtk::memory_manager::destroy_mutator fn">destroy_mutator</a></div><div class="item-right docblock-short"><p>Reclaim a mutator that is no longer needed.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.disable_collection.html" title="mmtk::memory_manager::disable_collection fn">disable_collection</a></div><div class="item-right docblock-short"><p>Disallow MMTk to trigger garbage collection. When collection is disabled, you can still allocate through MMTk. But MMTk will
not trigger a GC even if the heap is full. In such a case, the allocation will exceed the MMTk’s heap size (the soft heap limit).
However, there is no guarantee that the physical allocation will succeed, and if it succeeds, there is no guarantee that further allocation
will keep succeeding. So if a VM disables collection, it needs to allocate with careful consideration to make sure that the physical memory
allows the amount of allocation. We highly recommend not using this method. However, we support this to accomodate some VMs that require this
behavior. This call does not disable explicit GCs (through handle_user_collection_request()).
Note this call is not thread safe, only one VM thread should call this.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.enable_collection.html" title="mmtk::memory_manager::enable_collection fn">enable_collection</a></div><div class="item-right docblock-short"><p>Allow MMTk to trigger garbage collection when heap is full. This should only be used in pair with disable_collection().
See the comments on disable_collection(). If disable_collection() is not used, there is no need to call this function at all.
Note this call is not thread safe, only one VM thread should call this.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.flush_mutator.html" title="mmtk::memory_manager::flush_mutator fn">flush_mutator</a></div><div class="item-right docblock-short"><p>Flush the mutator’s local states.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.free_bytes.html" title="mmtk::memory_manager::free_bytes fn">free_bytes</a></div><div class="item-right docblock-short"><p>Return free memory in bytes.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.gc_init.html" title="mmtk::memory_manager::gc_init fn">gc_init</a></div><div class="item-right docblock-short"><p>Initialize an MMTk instance. A VM should call this method after creating an <a href="../mmtk/struct.MMTK.html">MMTK</a>
instance but before using any of the methods provided in MMTk. This method will attempt to initialize a
logger. If the VM would like to use its own logger, it should initialize the logger before calling this method.
Note that, to allow MMTk to do GC properly, <code>initialize_collection()</code> needs to be called after this call when
the VM’s thread system is ready to spawn GC workers.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.get_allocator_mapping.html" title="mmtk::memory_manager::get_allocator_mapping fn">get_allocator_mapping</a></div><div class="item-right docblock-short"><p>Return an AllocatorSelector for the given allocation semantic. This method is provided
so that VM compilers may call it to help generate allocation fast-path.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.get_finalized_object.html" title="mmtk::memory_manager::get_finalized_object fn">get_finalized_object</a></div><div class="item-right docblock-short"><p>Get an object that is ready for finalization. After each GC, if any registered object is not
alive, this call will return one of the objects. MMTk will retain the liveness of those objects
until they are popped through this call. Once an object is popped, it is the responsibility of
the VM to make sure they are properly finalized before reclaimed by the GC. This call is non-blocking,
and will return None if no object is ready for finalization.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.handle_user_collection_request.html" title="mmtk::memory_manager::handle_user_collection_request fn">handle_user_collection_request</a></div><div class="item-right docblock-short"><p>Trigger a garbage collection as requested by the user.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.harness_begin.html" title="mmtk::memory_manager::harness_begin fn">harness_begin</a></div><div class="item-right docblock-short"><p>Generic hook to allow benchmarks to be harnessed. We do a full heap
GC, and then start recording statistics for MMTk.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.harness_end.html" title="mmtk::memory_manager::harness_end fn">harness_end</a></div><div class="item-right docblock-short"><p>Generic hook to allow benchmarks to be harnessed. We stop collecting
statistics, and print stats values.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.initialize_collection.html" title="mmtk::memory_manager::initialize_collection fn">initialize_collection</a></div><div class="item-right docblock-short"><p>Initialize the scheduler and GC workers that are required for doing garbage collections.
This is a mandatory call for a VM during its boot process once its thread system
is ready. This should only be called once. This call will invoke Collection::spawn_gc_thread()
to create GC threads.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.is_live_object.html" title="mmtk::memory_manager::is_live_object fn">is_live_object</a></div><div class="item-right docblock-short"><p>Is the object alive?</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.is_mapped_address.html" title="mmtk::memory_manager::is_mapped_address fn">is_mapped_address</a></div><div class="item-right docblock-short"><p>Is the address in the mapped memory? The runtime can use this function to check
if an address is mapped by MMTk. Note that this is different than is_mapped_object().
For malloc spaces, MMTk does not map those addresses (malloc does the mmap), so
this function will return false, but is_mapped_object will return true if the address
is actually a valid object in malloc spaces. To check if an object is in our heap,
the runtime should always use is_mapped_object(). This function is_mapped_address()
may get removed at some point.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.is_mapped_object.html" title="mmtk::memory_manager::is_mapped_object fn">is_mapped_object</a></div><div class="item-right docblock-short"><p>Is the object in the mapped memory? The runtime can use this function to check
if an object is in MMTk heap.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.last_heap_address.html" title="mmtk::memory_manager::last_heap_address fn">last_heap_address</a></div><div class="item-right docblock-short"><p>Return the ending address of the heap. <em>Note that currently MMTk uses
a fixed address range as heap.</em></p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.modify_check.html" title="mmtk::memory_manager::modify_check fn">modify_check</a></div><div class="item-right docblock-short"><p>Check that if a garbage collection is in progress and if the given
object is not movable.  If it is movable error messages are
logged and the system exits.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.num_of_workers.html" title="mmtk::memory_manager::num_of_workers fn">num_of_workers</a></div><div class="item-right docblock-short"><p>Get the number of workers. MMTk spawns worker threads for the ‘threads’ defined in the options.
So the number of workers is derived from the threads option. Note the feature single_worker overwrites
the threads option, and force one worker thread.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.on_closure_end.html" title="mmtk::memory_manager::on_closure_end fn">on_closure_end</a></div><div class="item-right docblock-short"><p>Add a callback to be notified after the transitive closure is finished.
The callback should return true if it add more work packets to the closure bucket.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.post_alloc.html" title="mmtk::memory_manager::post_alloc fn">post_alloc</a></div><div class="item-right docblock-short"><p>Perform post-allocation actions, usually initializing object metadata. For many allocators none are
required. For performance reasons, a VM should implement the post alloc fast-path on their side
rather than just calling this function.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.process.html" title="mmtk::memory_manager::process fn">process</a></div><div class="item-right docblock-short"><p>Process MMTk run-time options. Returns true if the option is processed successfully.
We expect that only one thread should call <code>process()</code> or <code>process_bulk()</code> before <code>gc_init()</code> is called.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.process_bulk.html" title="mmtk::memory_manager::process_bulk fn">process_bulk</a></div><div class="item-right docblock-short"><p>Process multiple MMTk run-time options. Returns true if all the options are processed successfully.
We expect that only one thread should call <code>process()</code> or <code>process_bulk()</code> before <code>gc_init()</code> is called.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.start_control_collector.html" title="mmtk::memory_manager::start_control_collector fn">start_control_collector</a></div><div class="item-right docblock-short"><p>Run the main loop for the GC controller thread. This method does not return.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.start_worker.html" title="mmtk::memory_manager::start_worker fn">start_worker</a></div><div class="item-right docblock-short"><p>Run the main loop of a GC worker. This method does not return.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.starting_heap_address.html" title="mmtk::memory_manager::starting_heap_address fn">starting_heap_address</a></div><div class="item-right docblock-short"><p>Return the starting address of the heap. <em>Note that currently MMTk uses
a fixed address range as heap.</em></p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.total_bytes.html" title="mmtk::memory_manager::total_bytes fn">total_bytes</a></div><div class="item-right docblock-short"><p>Return the total memory in bytes.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.used_bytes.html" title="mmtk::memory_manager::used_bytes fn">used_bytes</a></div><div class="item-right docblock-short"><p>Return used memory in bytes.</p>
</div></div></div></section><section id="search" class="content hidden"></section></div></main><div id="rustdoc-vars" data-root-path="../../" data-current-crate="mmtk" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.60.0-nightly (e646f3d2a 2022-02-10)" ></div>
</body></html>