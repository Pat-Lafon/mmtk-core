<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Collection - MMTk Tutorial</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../../prefix.html">MMTk Tutorial</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.</strong> Introduction</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../intro/what_is_mmtk.html"><strong aria-hidden="true">1.1.</strong> What is MMTk?</a></li><li class="chapter-item expanded "><a href="../../intro/what_will_this_tutorial_cover.html"><strong aria-hidden="true">1.2.</strong> What will this tutorial cover?</a></li><li class="chapter-item expanded "><a href="../../intro/glossary.html"><strong aria-hidden="true">1.3.</strong> Glossary</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> Preliminaries</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../preliminaries/set_up.html"><strong aria-hidden="true">2.1.</strong> Set up MMTk and OpenJDK</a></li><li class="chapter-item expanded "><a href="../../preliminaries/test.html"><strong aria-hidden="true">2.2.</strong> Test the build</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> MyGC</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../mygc/create.html"><strong aria-hidden="true">3.1.</strong> Create MyGC</a></li><li class="chapter-item expanded "><a href="../../mygc/ss/prefix.html"><strong aria-hidden="true">3.2.</strong> Building a semispace GC</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../mygc/ss/alloc.html"><strong aria-hidden="true">3.2.1.</strong> Allocation</a></li><li class="chapter-item expanded "><a href="../../mygc/ss/collection.html" class="active"><strong aria-hidden="true">3.2.2.</strong> Collection</a></li><li class="chapter-item expanded "><a href="../../mygc/ss/exercise.html"><strong aria-hidden="true">3.2.3.</strong> Exercise</a></li><li class="chapter-item expanded "><a href="../../mygc/ss/exercise_solution.html"><strong aria-hidden="true">3.2.4.</strong> Exercise solution</a></li></ol></li><li class="chapter-item expanded "><a href="../../mygc/gencopy.html"><strong aria-hidden="true">3.3.</strong> Building a generational copying GC</a></li></ol></li><li class="chapter-item expanded "><a href="../../further_reading.html"><strong aria-hidden="true">4.</strong> Further Reading</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">MMTk Tutorial</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="collection-implement-garbage-collection"><a class="header" href="#collection-implement-garbage-collection">Collection: Implement garbage collection</a></h1>
<p>We need to add a few more things to get garbage collection working. 
Specifically, we need to config the <code>GCWorkerCopyContext</code>, which a GC worker uses for 
copying objects, and GC work packets that will be scheduled for a collection.</p>
<h2 id="copyconfig"><a class="header" href="#copyconfig">CopyConfig</a></h2>
<p><code>CopyConfig</code> defines how a GC plan copies objects.
Similar to the <code>MutatorConfig</code> struct, you would need to define <code>CopyConfig</code> for your plan.</p>
<p>In <code>impl&lt;VM: VMBinding&gt; Plan for MyGC&lt;VM&gt;</code>, override the method <code>create_copy_config()</code>.
The default implementation provides a default <code>CopyConfig</code> for non-copying plans. So for non-copying plans,
you do not need to override the method. But
for copying plans, you would have to provide a proper copy configuration.</p>
<p>In a semispace GC, objects will be copied between the two copy spaces. We will use one
<code>CopySpaceCopyContext</code> for the copying, and will rebind the copy context to the proper tospace
in the preparation step of a GC (which will be discussed later when we talk about preparing for collections).</p>
<p>We use <code>CopySemantics::DefaultCopy</code> for our copy
operation, and bind it with the first <code>CopySpaceCopyContext</code> (<code>CopySemantics::DefaultCopy =&gt; CopySelector::CopySpace(0)</code>).
Other copy semantics are unused in this plan. We also provide an initial space
binding for <code>CopySpaceCopyContext</code>. However, we will flip tospace in every GC, and rebind the
copy context to the new tospace in each GC, so it does not matter which space we use as the initial
space here.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn create_copy_config(&amp;'static self) -&gt; CopyConfig&lt;Self::VM&gt; {
        use enum_map::enum_map;
        CopyConfig {
            copy_mapping: enum_map! {
                CopySemantics::DefaultCopy =&gt; CopySelector::CopySpace(0),
                _ =&gt; CopySelector::Unused,
            },
            space_mapping: vec![
                // The tospace argument doesn't matter, we will rebind before a GC anyway.
                (CopySelector::CopySpace(0), &amp;self.copyspace0)
            ],
            constraints: &amp;MYGC_CONSTRAINTS,
        }
    }
<span class="boring">}
</span></code></pre></pre>
<h2 id="mygcprocessedges"><a class="header" href="#mygcprocessedges">MyGCProcessEdges</a></h2>
<p>We will create the tracing work packet for our GC.
At the moment, none of the files in the plan are suited for implementing this
GC packet. So, we need to add a new file to hold the <code>MyGCProcessEdges</code>.</p>
<p>Make a new file under <code>mygc</code>, called <code>gc_work.rs</code>. 
In <code>mod.rs</code>, import <code>gc_work</code> as a module by adding the line <code>mod gc_work</code>.
In <code>gc_work.rs</code>, add the following import statements:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use super::global::MyGC;
use crate::policy::space::Space;
use crate::scheduler::gc_work::*;
use crate::util::copy::CopySemantics;
use crate::util::{Address, ObjectReference};
use crate::vm::VMBinding;
use crate::MMTK;
use std::ops::{Deref, DerefMut};
<span class="boring">}
</span></code></pre></pre>
<p>Add a new public structure, <code>MyGCProcessEdges</code>, with the type parameter 
<code>&lt;VM:VMBinding&gt;</code>. It will hold an instance of <code>ProcessEdgesBase</code> and 
<code>MyGC</code>. This is the core part for tracing objects in the <code>MyGC</code> plan.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct MyGCProcessEdges&lt;VM: VMBinding&gt; {
    plan: &amp;'static MyGC&lt;VM&gt;,
    base: ProcessEdgesBase&lt;VM&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>Add a new implementations block 
<code>impl&lt;VM:VMBinding&gt; ProcessEdgesWork for MyGCProcessEdges&lt;VM&gt;</code>.
Similarly to before, set <code>ProcessEdgesWork</code>'s associate type <code>VM</code> to 
the type parameter of <code>MyGCProcessEdges</code>, <code>VM</code>: <code>type VM:VM</code>.
Add a new constructor, <code>new()</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn new(edges: Vec&lt;Address&gt;, roots: bool, mmtk: &amp;'static MMTK&lt;VM&gt;) -&gt; Self {
        let base = ProcessEdgesBase::new(edges, roots, mmtk);
        let plan = base.plan().downcast_ref::&lt;MyGC&lt;VM&gt;&gt;().unwrap();
        Self { base, plan }
    }
<span class="boring">}
</span></code></pre></pre>
<h2 id="introduce-collection-to-mygc-plan"><a class="header" href="#introduce-collection-to-mygc-plan">Introduce collection to MyGC plan</a></h2>
<p>Add a new method to <code>Plan for MyGC</code>, <code>schedule_collection()</code>. This function 
runs when a collection is triggered. It schedules GC work for the plan, i.e.,
it stops all mutators, runs the
scheduler's prepare stage and resumes the mutators. The <code>StopMutators</code> work
will invoke code from the bindings to scan threads and other roots, and those 
scanning work will further push work for a transitive closure.</p>
<p>Though you can add those work packets by yourself, <code>GCWorkScheduler</code> provides a
method <code>schedule_common_work()</code> that will add common work packets for you.</p>
<p>To use <code>schedule_common_work()</code>, first we need to create a type <code>MyGCWorkContext</code>
and implement the trait <code>GCWorkContext</code> for it. We create this type in <code>gc_work.rs</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct MyGCWorkContext&lt;VM: VMBinding&gt;(std::marker::PhantomData&lt;VM&gt;);
impl&lt;VM: VMBinding&gt; crate::scheduler::GCWorkContext for MyGCWorkContext&lt;VM&gt; {
    type VM = VM;
    type PlanType = MyGC&lt;VM&gt;;
    type ProcessEdgesWorkType = MyGCProcessEdges&lt;VM&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>Then we implement <code>schedule_collection()</code> using <code>MyGCWorkContext</code> and <code>schedule_common_work()</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn schedule_collection(&amp;'static self, scheduler: &amp;GCWorkScheduler&lt;VM&gt;) {
        self.base().set_collection_kind::&lt;Self&gt;(self);
        self.base().set_gc_status(GcStatus::GcPrepare);
        scheduler.schedule_common_work::&lt;MyGCWorkContext&lt;VM&gt;&gt;(self);
    }
<span class="boring">}
</span></code></pre></pre>
<p>Delete <code>handle_user_collection_request()</code>. This function was an override of 
a Common plan function to ignore user requested collection for NoGC. Now we 
remove it and allow user requested collection.</p>
<h2 id="prepare-for-collection"><a class="header" href="#prepare-for-collection">Prepare for collection</a></h2>
<p>The collector has a number of steps it needs to perform before each collection.
We'll add these now.</p>
<h3 id="prepare-plan"><a class="header" href="#prepare-plan">Prepare plan</a></h3>
<p>In <code>mygc/global.rs</code>, find the method <code>prepare</code>. Delete the <code>unreachable!()</code> 
call, and add the following code:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn prepare(&amp;mut self, tls: VMWorkerThread) {
        self.common.prepare(tls, true);

        self.hi
            .store(!self.hi.load(Ordering::SeqCst), Ordering::SeqCst);
        // Flips 'hi' to flip space definitions
        let hi = self.hi.load(Ordering::SeqCst);
        self.copyspace0.prepare(hi);
        self.copyspace1.prepare(!hi);
    }
<span class="boring">}
</span></code></pre></pre>
<p>This function is called at the start of a collection. It prepares the two 
spaces in the common plan, flips the definitions for which space is 'to' 
and which is 'from', then prepares the copyspaces with the new definition.</p>
<h3 id="prepare-worker"><a class="header" href="#prepare-worker">Prepare worker</a></h3>
<p>As we flip tospace for the plan, we also need to rebind the copy context
to the new tospace. We will override <code>prepare_worker()</code> in our <code>Plan</code> implementation.
<code>Plan.prepare_worker()</code> is executed by each GC worker in the preparation phase of a GC. The code
is straightforward -- we get the first <code>CopySpaceCopyContext</code>, and call <code>rebind()</code> on it with
the new <code>tospace</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn prepare_worker(&amp;self, worker: &amp;mut GCWorker&lt;VM&gt;) {
        unsafe { worker.get_copy_context_mut().copy[0].assume_init_mut() }.rebind(self.tospace());
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="prepare-mutator"><a class="header" href="#prepare-mutator">Prepare mutator</a></h3>
<p>Going back to <code>mutator.rs</code>, create a new function called 
<code>mygc_mutator_prepare(_mutator: &amp;mut Mutator &lt;MyGC&lt;VM&gt;&gt;, _tls: OpaquePointer,)</code>. 
This function will be called at the preparation stage of a collection 
(at the start of a collection) for each mutator. Its body can stay empty, as 
there aren't any preparation steps for the mutator in this GC.
In <code>create_mygc_mutator()</code>, find the field <code>prep_func</code> and change it from
<code>mygc_mutator_noop()</code> to <code>mygc_mutator_prepare()</code>.</p>
<h2 id="scan-objects"><a class="header" href="#scan-objects">Scan objects</a></h2>
<p>Next, we'll add the code to allow the plan to collect garbage - filling out 
functions for work packets.</p>
<p>In <code>gc_work.rs</code>, add a new method to <code>ProcessEdgesWork for MyGCProcessEdges</code>,
<code>trace_object(&amp;mut self, object: ObjectReference)</code>.
This method should return an ObjectReference, and use the 
inline attribute.
Check if the object passed into the function is null 
(<code>object.is_null()</code>). If it is, return the object.
Otherwise, check which space the object is in, and forward the call to the 
policy-specific object tracing code. If it is in neither space, forward the 
call to the common space and let the common space to handle object tracing in 
its spaces (e.g. immortal or large object space):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    #[inline]
    fn trace_object(&amp;mut self, object: ObjectReference) -&gt; ObjectReference {
        if object.is_null() {
            return object;
        }
        if self.mygc().tospace().in_space(object) {
            self.mygc().tospace().trace_object::&lt;Self&gt;(
                self,
                object,
                CopySemantics::DefaultCopy,
                self.worker(),
            )
        } else if self.mygc().fromspace().in_space(object) {
            self.mygc().fromspace().trace_object::&lt;Self&gt;(
                self,
                object,
                CopySemantics::DefaultCopy,
                self.worker(),
            )
        } else {
            self.mygc().common.trace_object::&lt;Self&gt;(self, object)
        }
    }
<span class="boring">}
</span></code></pre></pre>
<p>Add two new implementation blocks, <code>Deref</code> and <code>DerefMut</code> for 
<code>MyGCProcessEdges</code>. These allow <code>MyGCProcessEdges</code> to be dereferenced to 
<code>ProcessEdgesBase</code>, and allows easy access to fields in <code>ProcessEdgesBase</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;VM: VMBinding&gt; Deref for MyGCProcessEdges&lt;VM&gt; {
    type Target = ProcessEdgesBase&lt;VM&gt;;
    #[inline]
    fn deref(&amp;self) -&gt; &amp;Self::Target {
        &amp;self.base
    }
}

impl&lt;VM: VMBinding&gt; DerefMut for MyGCProcessEdges&lt;VM&gt; {
    #[inline]
    fn deref_mut(&amp;mut self) -&gt; &amp;mut Self::Target {
        &amp;mut self.base
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="release"><a class="header" href="#release">Release</a></h2>
<p>Finally, we need to fill out the functions that are, roughly speaking, 
run after each collection.</p>
<h3 id="release-in-plan"><a class="header" href="#release-in-plan">Release in plan</a></h3>
<p>Find the method <code>release()</code> in <code>mygc/global.rs</code>. Replace the 
<code>unreachable!()</code> call with the following code.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn release(&amp;mut self, tls: VMWorkerThread) {
        self.common.release(tls, true);
        self.fromspace().release();
    }
<span class="boring">}
</span></code></pre></pre>
<p>This function is called at the end of a collection. It calls the release 
routines for the common plan spaces and the fromspace.</p>
<h3 id="release-in-mutator"><a class="header" href="#release-in-mutator">Release in mutator</a></h3>
<p>Go back to <code>mutator.rs</code>. In <code>create_mygc_mutator()</code>, replace 
<code>mygc_mutator_noop()</code> in the <code>release_func</code> field with <code>mygc_mutator_release()</code>.
Leave the <code>release()</code> function in the <code>CopyContext</code> empty. There are no 
release steps for <code>CopyContext</code> in this collector.</p>
<p>Create a new function called <code>mygc_mutator_release()</code> that takes the same 
inputs as the <code>prepare()</code> function above. This function will be called at the 
release stage of a collection (at the end of a collection) for each mutator. 
It rebinds the allocator for the <code>Default</code> allocation semantics to the new 
tospace. When the mutator threads resume, any new allocations for <code>Default</code> 
will then go to the new tospace.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn mygc_mutator_release&lt;VM: VMBinding&gt;(
    mutator: &amp;mut Mutator&lt;VM&gt;,
    _tls: VMWorkerThread,
) {
    // rebind the allocation bump pointer to the appropriate semispace
    let bump_allocator = unsafe {
        mutator
            .allocators
            .get_allocator_mut(mutator.config.allocator_mapping[AllocationSemantics::Default])
    }
    .downcast_mut::&lt;BumpAllocator&lt;VM&gt;&gt;()
    .unwrap();
    bump_allocator.rebind(
        mutator
            .plan
            .downcast_ref::&lt;MyGC&lt;VM&gt;&gt;()
            .unwrap()
            .tospace(),
    );
}
<span class="boring">}
</span></code></pre></pre>
<p>Delete <code>mygc_mutator_noop()</code>. It was a placeholder for the prepare and 
release functions that you have now added, so it is now dead code.</p>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>You should now have MyGC working and able to collect garbage. All three
benchmarks should be able to pass now. </p>
<p>If the benchmarks pass - good job! You have built a functional copying
collector!</p>
<p>If you get particularly stuck, the code for the completed <code>MyGC</code> plan
is available <a href="https://github.com/mmtk/mmtk-core/tree/master/docs/tutorial/code/mygc_semispace">here</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../mygc/ss/alloc.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../../mygc/ss/exercise.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../mygc/ss/alloc.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../../mygc/ss/exercise.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
