<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="VM-specific methods for garbage collection."><meta name="keywords" content="rust, rustlang, rust-lang, Collection"><title>Collection in mmtk::vm - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" href="../../normalize.css"><link rel="stylesheet" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" href="../../ayu.css" disabled><link rel="stylesheet" href="../../dark.css" disabled><link rel="stylesheet" href="../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../storage.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../main.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../favicon.svg"></head><body class="rustdoc trait"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../../mmtk/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div></a><h2></h2></nav><nav class="sidebar"><a class="sidebar-logo" href="../../mmtk/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div></a><h2 class="location"><a href="#">Collection</a></h2><div class="sidebar-elems"><section><h3><a href="#required-methods">Required Methods</a></h3><ul class="block"><li><a href="#tymethod.block_for_gc">block_for_gc</a></li><li><a href="#tymethod.prepare_mutator">prepare_mutator</a></li><li><a href="#tymethod.resume_mutators">resume_mutators</a></li><li><a href="#tymethod.spawn_gc_thread">spawn_gc_thread</a></li><li><a href="#tymethod.stop_all_mutators">stop_all_mutators</a></li></ul><h3><a href="#provided-methods">Provided Methods</a></h3><ul class="block"><li><a href="#method.out_of_memory">out_of_memory</a></li><li><a href="#method.post_forwarding">post_forwarding</a></li><li><a href="#method.schedule_finalization">schedule_finalization</a></li></ul><h3><a href="#implementors">Implementors</a></h3></section><h2><a href="index.html">In mmtk::vm</a></h2></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../wheel.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1 class="fqn">Trait <a href="../index.html">mmtk</a>::<wbr><a href="index.html">vm</a>::<wbr><a class="trait" href="#">Collection</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../../clipboard.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../../src/mmtk/vm/collection.rs.html#14-114">source</a> · <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></div><div class="item-decl"><pre class="rust trait"><code>pub trait Collection&lt;VM:&nbsp;<a class="trait" href="trait.VMBinding.html" title="trait mmtk::vm::VMBinding">VMBinding</a>&gt; {
    fn <a href="#tymethod.stop_all_mutators" class="fnname">stop_all_mutators</a>&lt;F&gt;(tls: <a class="struct" href="../util/opaque_pointer/struct.VMWorkerThread.html" title="struct mmtk::util::opaque_pointer::VMWorkerThread">VMWorkerThread</a>, mutator_visitor: F)<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="where">where<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(&amp;'static mut <a class="struct" href="../plan/struct.Mutator.html" title="struct mmtk::plan::Mutator">Mutator</a>&lt;VM&gt;)</span>;
<span class="item-spacer"></span>    fn <a href="#tymethod.resume_mutators" class="fnname">resume_mutators</a>(tls: <a class="struct" href="../util/opaque_pointer/struct.VMWorkerThread.html" title="struct mmtk::util::opaque_pointer::VMWorkerThread">VMWorkerThread</a>);
<span class="item-spacer"></span>    fn <a href="#tymethod.block_for_gc" class="fnname">block_for_gc</a>(tls: <a class="struct" href="../util/opaque_pointer/struct.VMMutatorThread.html" title="struct mmtk::util::opaque_pointer::VMMutatorThread">VMMutatorThread</a>);
<span class="item-spacer"></span>    fn <a href="#tymethod.spawn_gc_thread" class="fnname">spawn_gc_thread</a>(tls: <a class="struct" href="../util/opaque_pointer/struct.VMThread.html" title="struct mmtk::util::opaque_pointer::VMThread">VMThread</a>, ctx: <a class="enum" href="enum.GCThreadContext.html" title="enum mmtk::vm::GCThreadContext">GCThreadContext</a>&lt;VM&gt;);
<span class="item-spacer"></span>    fn <a href="#tymethod.prepare_mutator" class="fnname">prepare_mutator</a>&lt;T:&nbsp;<a class="trait" href="../plan/trait.MutatorContext.html" title="trait mmtk::plan::MutatorContext">MutatorContext</a>&lt;VM&gt;&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tls_worker: <a class="struct" href="../util/opaque_pointer/struct.VMWorkerThread.html" title="struct mmtk::util::opaque_pointer::VMWorkerThread">VMWorkerThread</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tls_mutator: <a class="struct" href="../util/opaque_pointer/struct.VMMutatorThread.html" title="struct mmtk::util::opaque_pointer::VMMutatorThread">VMMutatorThread</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>T<br>&nbsp;&nbsp;&nbsp;&nbsp;);

    fn <a href="#method.out_of_memory" class="fnname">out_of_memory</a>(_tls: <a class="struct" href="../util/opaque_pointer/struct.VMThread.html" title="struct mmtk::util::opaque_pointer::VMThread">VMThread</a>, err_kind: <a class="enum" href="../util/alloc/enum.AllocationError.html" title="enum mmtk::util::alloc::AllocationError">AllocationError</a>) { ... }
<span class="item-spacer"></span>    fn <a href="#method.schedule_finalization" class="fnname">schedule_finalization</a>(_tls: <a class="struct" href="../util/opaque_pointer/struct.VMWorkerThread.html" title="struct mmtk::util::opaque_pointer::VMWorkerThread">VMWorkerThread</a>) { ... }
<span class="item-spacer"></span>    fn <a href="#method.post_forwarding" class="fnname">post_forwarding</a>(_tls: <a class="struct" href="../util/opaque_pointer/struct.VMWorkerThread.html" title="struct mmtk::util::opaque_pointer::VMWorkerThread">VMWorkerThread</a>) { ... }
}</code></pre></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>VM-specific methods for garbage collection.</p>
</div></details><h2 id="required-methods" class="small-section-header">Required Methods<a href="#required-methods" class="anchor"></a></h2><div class="methods"><details class="rustdoc-toggle method-toggle" open><summary><section id="tymethod.stop_all_mutators" class="method has-srclink"><a class="srclink rightside" href="../../src/mmtk/vm/collection.rs.html#22-24">source</a><h4 class="code-header">fn <a href="#tymethod.stop_all_mutators" class="fnname">stop_all_mutators</a>&lt;F&gt;(tls: <a class="struct" href="../util/opaque_pointer/struct.VMWorkerThread.html" title="struct mmtk::util::opaque_pointer::VMWorkerThread">VMWorkerThread</a>, mutator_visitor: F)<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.66.1/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(&amp;'static mut <a class="struct" href="../plan/struct.Mutator.html" title="struct mmtk::plan::Mutator">Mutator</a>&lt;VM&gt;),</span></h4></section></summary><div class="docblock"><p>Stop all the mutator threads. MMTk calls this method when it requires all the mutator to yield for a GC.
This method is called by a single thread in MMTk (the GC controller).
This method should not return until all the threads are yielded.
The actual thread synchronization mechanism is up to the VM, and MMTk does not make assumptions on that.</p>
<p>Arguments:</p>
<ul>
<li><code>tls</code>: The thread pointer for the GC controller/coordinator.</li>
</ul>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="tymethod.resume_mutators" class="method has-srclink"><a class="srclink rightside" href="../../src/mmtk/vm/collection.rs.html#30">source</a><h4 class="code-header">fn <a href="#tymethod.resume_mutators" class="fnname">resume_mutators</a>(tls: <a class="struct" href="../util/opaque_pointer/struct.VMWorkerThread.html" title="struct mmtk::util::opaque_pointer::VMWorkerThread">VMWorkerThread</a>)</h4></section></summary><div class="docblock"><p>Resume all the mutator threads, the opposite of the above. When a GC is finished, MMTk calls this method.</p>
<p>Arguments:</p>
<ul>
<li><code>tls</code>: The thread pointer for the GC controller/coordinator.</li>
</ul>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="tymethod.block_for_gc" class="method has-srclink"><a class="srclink rightside" href="../../src/mmtk/vm/collection.rs.html#39">source</a><h4 class="code-header">fn <a href="#tymethod.block_for_gc" class="fnname">block_for_gc</a>(tls: <a class="struct" href="../util/opaque_pointer/struct.VMMutatorThread.html" title="struct mmtk::util::opaque_pointer::VMMutatorThread">VMMutatorThread</a>)</h4></section></summary><div class="docblock"><p>Block the current thread for GC. This is called when an allocation request cannot be fulfilled and a GC
is needed. MMTk calls this method to inform the VM that the current thread needs to be blocked as a GC
is going to happen. Then MMTk starts a GC. For a stop-the-world GC, MMTk will then call <code>stop_all_mutators()</code>
before the GC, and call <code>resume_mutators()</code> after the GC.</p>
<p>Arguments:</p>
<ul>
<li><code>tls</code>: The current thread pointer that should be blocked. The VM can optionally check if the current thread matches <code>tls</code>.</li>
</ul>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="tymethod.spawn_gc_thread" class="method has-srclink"><a class="srclink rightside" href="../../src/mmtk/vm/collection.rs.html#55">source</a><h4 class="code-header">fn <a href="#tymethod.spawn_gc_thread" class="fnname">spawn_gc_thread</a>(tls: <a class="struct" href="../util/opaque_pointer/struct.VMThread.html" title="struct mmtk::util::opaque_pointer::VMThread">VMThread</a>, ctx: <a class="enum" href="enum.GCThreadContext.html" title="enum mmtk::vm::GCThreadContext">GCThreadContext</a>&lt;VM&gt;)</h4></section></summary><div class="docblock"><p>Ask the VM to spawn a GC thread for MMTk. A GC thread may later call into the VM through these VM traits. Some VMs
have assumptions that those calls needs to be within VM internal threads.
As a result, MMTk does not spawn GC threads itself to avoid breaking this kind of assumptions.
MMTk calls this method to spawn GC threads during <a href="../memory_manager/fn.initialize_collection.html"><code>initialize_collection()</code></a>.</p>
<p>Arguments:</p>
<ul>
<li><code>tls</code>: The thread pointer for the parent thread that we spawn new threads from. This is the same <code>tls</code> when the VM
calls <code>initialize_collection()</code> and passes as an argument.</li>
<li><code>ctx</code>: The context for the GC thread.
<ul>
<li>If <code>Controller</code> is passed, it means spawning a thread to run as the GC controller.
The spawned thread shall call <code>memory_manager::start_control_collector</code>.</li>
<li>If <code>Worker</code> is passed, it means spawning a thread to run as a GC worker.
The spawned thread shall call <code>memory_manager::start_worker</code>.
In either case, the <code>Box</code> inside should be passed back to the called function.</li>
</ul>
</li>
</ul>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="tymethod.prepare_mutator" class="method has-srclink"><a class="srclink rightside" href="../../src/mmtk/vm/collection.rs.html#63-67">source</a><h4 class="code-header">fn <a href="#tymethod.prepare_mutator" class="fnname">prepare_mutator</a>&lt;T:&nbsp;<a class="trait" href="../plan/trait.MutatorContext.html" title="trait mmtk::plan::MutatorContext">MutatorContext</a>&lt;VM&gt;&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;tls_worker: <a class="struct" href="../util/opaque_pointer/struct.VMWorkerThread.html" title="struct mmtk::util::opaque_pointer::VMWorkerThread">VMWorkerThread</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;tls_mutator: <a class="struct" href="../util/opaque_pointer/struct.VMMutatorThread.html" title="struct mmtk::util::opaque_pointer::VMMutatorThread">VMMutatorThread</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;m: <a class="primitive" href="https://doc.rust-lang.org/1.66.1/std/primitive.reference.html">&amp;</a>T<br>)</h4></section></summary><div class="docblock"><p>Allow VM-specific behaviors for a mutator after all the mutators are stopped and before any actual GC work starts.</p>
<p>Arguments:</p>
<ul>
<li><code>tls_worker</code>: The thread pointer for the worker thread performing this call.</li>
<li><code>tls_mutator</code>: The thread pointer for the target mutator thread.</li>
<li><code>m</code>: The mutator context for the thread.</li>
</ul>
</div></details></div><h2 id="provided-methods" class="small-section-header">Provided Methods<a href="#provided-methods" class="anchor"></a></h2><div class="methods"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.out_of_memory" class="method has-srclink"><a class="srclink rightside" href="../../src/mmtk/vm/collection.rs.html#82-84">source</a><h4 class="code-header">fn <a href="#method.out_of_memory" class="fnname">out_of_memory</a>(_tls: <a class="struct" href="../util/opaque_pointer/struct.VMThread.html" title="struct mmtk::util::opaque_pointer::VMThread">VMThread</a>, err_kind: <a class="enum" href="../util/alloc/enum.AllocationError.html" title="enum mmtk::util::alloc::AllocationError">AllocationError</a>)</h4></section></summary><div class="docblock"><p>Inform the VM of an out-of-memory error. The binding should hook into the VM’s error
routine for OOM. Note that there are two different categories of OOM:</p>
<ul>
<li>Critical OOM: This is the case where the OS is unable to mmap or acquire more memory.
MMTk expects the VM to abort immediately if such an error is thrown.</li>
<li>Heap OOM: This is the case where the specified heap size is insufficient to execute the
application. MMTk expects the binding to notify the VM about this OOM. MMTk makes no
assumptions about whether the VM will continue executing or abort immediately.</li>
</ul>
<p>See <a href="../util/alloc/enum.AllocationError.html" title="AllocationError"><code>AllocationError</code></a> for more information.</p>
<p>Arguments:</p>
<ul>
<li><code>tls</code>: The thread pointer for the mutator which failed the allocation and triggered the OOM.</li>
<li><code>err_kind</code>: The type of OOM error that was encountered.</li>
</ul>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.schedule_finalization" class="method has-srclink"><a class="srclink rightside" href="../../src/mmtk/vm/collection.rs.html#90">source</a><h4 class="code-header">fn <a href="#method.schedule_finalization" class="fnname">schedule_finalization</a>(_tls: <a class="struct" href="../util/opaque_pointer/struct.VMWorkerThread.html" title="struct mmtk::util::opaque_pointer::VMWorkerThread">VMWorkerThread</a>)</h4></section></summary><div class="docblock"><p>Inform the VM to schedule finalization threads.</p>
<p>Arguments:</p>
<ul>
<li><code>tls</code>: The thread pointer for the current GC thread.</li>
</ul>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.post_forwarding" class="method has-srclink"><a class="srclink rightside" href="../../src/mmtk/vm/collection.rs.html#113">source</a><h4 class="code-header">fn <a href="#method.post_forwarding" class="fnname">post_forwarding</a>(_tls: <a class="struct" href="../util/opaque_pointer/struct.VMWorkerThread.html" title="struct mmtk::util::opaque_pointer::VMWorkerThread">VMWorkerThread</a>)</h4></section></summary><div class="docblock"><p>A hook for the VM to do work after forwarding objects.</p>
<p>This function is called after all of the following have finished:</p>
<ul>
<li>The life and death of objects are determined.  Objects determined to be live will not
be reclaimed in this GC.</li>
<li>Live objects have been moved to their destinations. (copying GC only)</li>
<li>References in objects have been updated to point to new addresses. (copying GC only)</li>
</ul>
<p>And this function may run concurrently with the release work of GC, i.e. freeing the space
occupied by dead objects.</p>
<p>It is safe for the VM to read and write object fields at this time, although GC has not
finished yet.  GC will be reclaiming spaces of dead objects, but will not damage live
objects.  However, the VM cannot allocate new objects at this time.</p>
<p>One possible use of this hook is enqueuing <code>{Soft,Weak,Phantom}Reference</code> instances to
reference queues (for Java).  VMs (including JVM implementations) do not have to handle
weak references this way, but mmtk-core provides this opportunity.</p>
<p>Arguments:</p>
<ul>
<li><code>tls_worker</code>: The thread pointer for the worker thread performing this call.</li>
</ul>
</div></details></div><h2 id="implementors" class="small-section-header">Implementors<a href="#implementors" class="anchor"></a></h2><div id="implementors-list"></div><script src="../../implementors/mmtk/vm/collection/trait.Collection.js" async></script></section></div></main><div id="rustdoc-vars" data-root-path="../../" data-current-crate="mmtk" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.66.1 (90743e729 2023-01-10)" ></div></body></html>