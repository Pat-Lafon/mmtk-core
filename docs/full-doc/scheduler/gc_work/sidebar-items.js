initSidebarItems({"struct":[["EndOfGC",""],["PlanProcessEdges","This provides an implementation of [`crate::scheduler::gc_work::ProcessEdgesWork`]. A plan that implements `PlanTraceObject` can use this work packet for tracing objects."],["PlanScanObjects","This is an alternative to `ScanObjects` that calls the `post_scan_object` of the policy selected by the plan.  It is applicable to plans that derive `PlanTraceObject`."],["Prepare","The global GC Preparation Work This work packet invokes prepare() for the plan (which will invoke prepare() for each space), and pushes work packets for preparing mutators and collectors. We should only have one such work packet per GC, before any actual GC work starts. We assume this work packet is the only running work packet that accesses plan, and there should be no other concurrent work packet that accesses plan (read or write). Otherwise, there may be a race condition."],["PrepareCollector","The collector GC Preparation Work"],["PrepareMutator","The mutator GC Preparation Work"],["ProcessEdgesBase",""],["ProcessEdgesWorkRootsWorkFactory",""],["ProcessEdgesWorkTracer","This implements `ObjectTracer` by forwarding the `trace_object` calls to the wrapped `ProcessEdgesWork` instance."],["ProcessEdgesWorkTracerContext","This type implements `ObjectTracerContext` by creating a temporary `ProcessEdgesWork` during the call to `with_tracer`, making use of its `trace_object` method.  It then creates work packets using the methods of the `ProcessEdgesWork` and add the work packet into the given `stage`."],["Release","The global GC release Work This work packet invokes release() for the plan (which will invoke release() for each space), and pushes work packets for releasing mutators and collectors. We should only have one such work packet per GC, after all actual GC work ends. We assume this work packet is the only running work packet that accesses plan, and there should be no other concurrent work packet that accesses plan (read or write). Otherwise, there may be a race condition."],["ReleaseCollector","The collector release Work"],["ReleaseMutator","The mutator release Work"],["SFTProcessEdges","A general process edges implementation using SFT. A plan can always implement their own process edges. However, Most plans can use this work packet for tracing amd they do not need to provide a plan-specific trace object work packet. If they choose to use this type, they need to provide a correct implementation for some related methods (such as `Space.set_copy_for_sft_trace()`, `SFT.sft_trace_object()`). Some plans are not using this type, mostly due to more complex tracing. Either it is impossible to use this type, or there is performance overheads for using this general trace type. In such cases, they implement their specific process edges."],["ScanObjects","Scan objects and enqueue the edges of the objects.  For objects that do not support edge-enqueuing, this work packet also processes the edges."],["ScanStackRoot",""],["ScanStackRoots",""],["ScanVMSpecificRoots",""],["ScheduleCollection",""],["StopMutators","Stop all mutators"],["VMForwardWeakRefs","Delegate to the VM binding for forwarding weak references."],["VMPostForwarding","This work packet calls `Collection::post_forwarding`."],["VMProcessWeakRefs","Delegate to the VM binding for weak reference processing."]],"trait":[["ProcessEdgesWork","Scan & update a list of object slots"],["ScanObjectsWork","Trait for a work packet that scans objects"]],"type":[["EdgeOf","A short-hand for `<E::VM as VMBinding>::VMEdge`."]]});